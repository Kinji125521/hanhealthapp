{"version":3,"file":"static/js/main.de626a0c.js","mappings":"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","sources":["utils/history.js","utils/token.js","utils/http.js","utils/remstoreUtils.js","utils/storageUtils.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/@remix-run/router/history.ts","../node_modules/@remix-run/router/utils.ts","../node_modules/@remix-run/router/router.ts","../node_modules/axios/node_modules/form-data/lib/browser.js","../node_modules/react-dom/client.js","../node_modules/react-router-dom/dom.ts","../node_modules/react-router-dom/index.tsx","../node_modules/react-router/lib/use-sync-external-store-shim/useSyncExternalStoreShimClient.ts","../node_modules/react-router/lib/use-sync-external-store-shim/index.ts","../node_modules/react-router/lib/use-sync-external-store-shim/useSyncExternalStoreShimServer.ts","../node_modules/react-router/lib/context.ts","../node_modules/react-router/lib/hooks.tsx","../node_modules/react-router/lib/components.tsx","../node_modules/react/cjs/react-jsx-runtime.production.min.js","../node_modules/react/jsx-runtime.js","../node_modules/store/dist/store.legacy.js","../node_modules/store/plugins/json2.js","../node_modules/store/plugins/lib/json2.js","../node_modules/store/src/store-engine.js","../node_modules/store/src/util.js","../node_modules/store/storages/all.js","../node_modules/store/storages/cookieStorage.js","../node_modules/store/storages/localStorage.js","../node_modules/store/storages/memoryStorage.js","../node_modules/store/storages/oldFF-globalStorage.js","../node_modules/store/storages/oldIE-userDataStorage.js","../node_modules/store/storages/sessionStorage.js","../external var \"React\"","../external var \"ReactDOM\"","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/toArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/axios/lib/helpers/bind.js","../node_modules/axios/lib/utils.js","../node_modules/axios/lib/core/AxiosError.js","../node_modules/axios/lib/env/classes/FormData.js","../node_modules/axios/lib/helpers/toFormData.js","../node_modules/axios/lib/helpers/AxiosURLSearchParams.js","../node_modules/axios/lib/helpers/buildURL.js","../node_modules/axios/lib/core/InterceptorManager.js","../node_modules/axios/lib/defaults/transitional.js","../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js","../node_modules/axios/lib/platform/browser/classes/FormData.js","../node_modules/axios/lib/platform/browser/index.js","../node_modules/axios/lib/helpers/formDataToJSON.js","../node_modules/axios/lib/defaults/index.js","../node_modules/axios/lib/helpers/toURLEncodedForm.js","../node_modules/axios/lib/helpers/parseHeaders.js","../node_modules/axios/lib/core/AxiosHeaders.js","../node_modules/axios/lib/core/transformData.js","../node_modules/axios/lib/cancel/isCancel.js","../node_modules/axios/lib/cancel/CanceledError.js","../node_modules/axios/lib/helpers/cookies.js","../node_modules/axios/lib/core/buildFullPath.js","../node_modules/axios/lib/helpers/isAbsoluteURL.js","../node_modules/axios/lib/helpers/combineURLs.js","../node_modules/axios/lib/helpers/isURLSameOrigin.js","../node_modules/axios/lib/helpers/speedometer.js","../node_modules/axios/lib/adapters/xhr.js","../node_modules/axios/lib/adapters/adapters.js","../node_modules/axios/lib/helpers/null.js","../node_modules/axios/lib/core/settle.js","../node_modules/axios/lib/helpers/parseProtocol.js","../node_modules/axios/lib/core/dispatchRequest.js","../node_modules/axios/lib/core/mergeConfig.js","../node_modules/axios/lib/env/data.js","../node_modules/axios/lib/helpers/validator.js","../node_modules/axios/lib/core/Axios.js","../node_modules/axios/lib/cancel/CancelToken.js","../node_modules/axios/lib/helpers/HttpStatusCode.js","../node_modules/axios/lib/axios.js","../node_modules/axios/lib/helpers/spread.js","../node_modules/axios/lib/helpers/isAxiosError.js","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/load script","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/css loading","../webpack/runtime/jsonp chunk loading","components/AuthComponent.js","App.js","index.js"],"sourcesContent":["import { createBrowserHistory } from 'history'\r\n\r\nconst history = createBrowserHistory()\r\n\r\nexport { history }","// 封裝 ls 存取 token\r\n\r\nconst key = 'pc-key'\r\n\r\n// 存\r\nconst setToken = (token) => {\r\n  return window.localStorage.setItem(key, token)\r\n}\r\n\r\n// 取\r\nconst getToken = () => {\r\n  return window.localStorage.getItem(key)\r\n}\r\n\r\n// 刪\r\nconst removeToken = () => {\r\n  return window.localStorage.removeItem(key)\r\n}\r\n\r\nexport {\r\n  setToken,\r\n  getToken,\r\n  removeToken\r\n}","// 封裝 axios\r\n// 實例化 / 請求攔截器 / 響應攔截器\r\n\r\nimport axios from 'axios'\r\n//import { history } from './history'\r\nimport { getToken, removeToken } from './token'\r\nimport { getUser, removeUser } from './storageUtils'\r\nimport { history } from './history'\r\n\r\nconst http = axios.create({\r\n  baseURL: 'http://192.168.11.118:7000/',\r\n  timeout: 5000\r\n})\r\n// 添加请求拦截器\r\nhttp.interceptors.request.use((config) => {\r\n  // if not login add token\r\n  const token = getToken()\r\n  if (token) {\r\n    config.headers.Authorization = `Bearer ${token}`\r\n  }\r\n  return config\r\n}, (error) => {\r\n  return Promise.reject(error)\r\n})\r\n\r\n// 添加响应拦截器\r\nhttp.interceptors.response.use((response) => {\r\n  // 2xx 范围内的状态码都会触发该函数。\r\n  // 对响应数据做点什么\r\n  return response.data\r\n}, (error) => {\r\n  // 超出 2xx 范围的状态码都会触发该函数。\r\n  // 对响应错误做点什么\r\n  console.dir(error)\r\n  if (error.response.status === 401) {\r\n    // 跳回到登錄\r\n    // reactRouter 默認狀態下，並不支持在組件之外完成路由跳轉，因此需要自己來實現\r\n    // 刪除 token\r\n    removeToken()\r\n    removeUser()\r\n    // 跳轉到登錄頁\r\n    history.push('/login')\r\n  }\r\n  return Promise.reject(error)\r\n})\r\n\r\nexport { http }","/**\r\n * 此模块是用于local数据存储管理的工具模块\r\n */\r\nimport store from 'store'\r\n\r\nconst USER_KEY = 'remember'\r\n\r\n\r\n\r\n/**\r\n * 存储rem\r\n */\r\nconst saveRem = (rem) => {\r\n  store.set(USER_KEY, rem)\r\n}\r\n\r\n/**\r\n * 获取rem\r\n */\r\nconst getRem = () => {\r\n  // return JSON.parse(localStorage.getItem(USER_KEY) || '{}')\r\n  return store.get(USER_KEY) || {}\r\n}\r\n\r\n/**\r\n* 删除tel\r\n*/\r\nconst removeRem = () => {\r\n  //window.localStorage.removeItem(USER_KEY)\r\n  store.remove(USER_KEY)\r\n}\r\n\r\n\r\nexport { saveRem, getRem, removeRem }","/**\r\n * 此模块是用于local数据存储管理的工具模块\r\n */\r\nimport store from 'store'\r\n\r\nconst USER_KEY = 'user_key'\r\n\r\n\r\n\r\n/**\r\n * 存储tel\r\n */\r\nconst saveUser = (tel) => {\r\n  store.set(USER_KEY, tel)\r\n}\r\n\r\n/**\r\n * 获取tel\r\n */\r\nconst getUser = () => {\r\n  // return JSON.parse(localStorage.getItem(USER_KEY) || '{}')\r\n  return store.get(USER_KEY) || {}\r\n}\r\n\r\n/**\r\n* 删除tel\r\n*/\r\nconst removeUser = () => {\r\n  //window.localStorage.removeItem(USER_KEY)\r\n  store.remove(USER_KEY)\r\n}\r\n\r\n\r\nexport { saveUser, getUser, removeUser }","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: any;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. May be either a URL or the pieces of a\n * URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLACE navigations for data routers\n   * behave the same as POP\n   *\n   * @param to Unencoded path\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref(to) {\n      return typeof to === \"string\" ? to : createPath(to);\n    },\n    encodeLocation(to: To) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\",\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      index = clampIndex(index + delta);\n      if (listener) {\n        listener({ action, location: getCurrentLocation() });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nfunction warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport function createClientSideURL(location: Location | string): URL {\n  // window.location.origin is \"null\" (the literal string value) in Firefox\n  // under certain conditions, notably when serving from a local HTML file\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n  let base =\n    typeof window !== \"undefined\" &&\n    typeof window.location !== \"undefined\" &&\n    window.location.origin !== \"null\"\n      ? window.location.origin\n      : window.location.href;\n  let href = typeof location === \"string\" ? location : createPath(location);\n  invariant(\n    base,\n    `No window.location.(origin|href) available to create URL for href: ${href}`\n  );\n  return new URL(href, base);\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function handlePop() {\n    action = Action.Pop;\n    if (listener) {\n      listener({ action, location: history.location });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    let historyState = getHistoryState(location);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    let historyState = getHistoryState(location);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location });\n    }\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createClientSideURL(\n        typeof to === \"string\" ? to : createPath(to)\n      );\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n","import type { Location, Path, To } from \"./history\";\nimport { invariant, parsePath } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: any;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  status: number;\n  location: string;\n  revalidate: boolean;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: any;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\nexport type MutationFormMethod = \"post\" | \"put\" | \"patch\" | \"delete\";\nexport type FormMethod = \"get\" | MutationFormMethod;\n\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\";\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport interface Submission {\n  formMethod: FormMethod;\n  formAction: string;\n  formEncType: FormEncType;\n  formData: FormData;\n}\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs {\n  request: Request;\n  params: Params;\n  context?: any;\n}\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs extends DataFunctionArgs {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs extends DataFunctionArgs {}\n\n/**\n * Route loader function signature\n */\nexport interface LoaderFunction {\n  (args: LoaderFunctionArgs): Promise<Response> | Response | Promise<any> | any;\n}\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction {\n  (args: ActionFunctionArgs): Promise<Response> | Response | Promise<any> | any;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: {\n    currentUrl: URL;\n    currentParams: AgnosticDataRouteMatch[\"params\"];\n    nextUrl: URL;\n    nextParams: AgnosticDataRouteMatch[\"params\"];\n    formMethod?: Submission[\"formMethod\"];\n    formAction?: Submission[\"formAction\"];\n    formEncType?: Submission[\"formEncType\"];\n    formData?: Submission[\"formData\"];\n    actionResult?: DataResult;\n    defaultShouldRevalidate: boolean;\n  }): boolean;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `:${infer Param}`\n    ? Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\ntype PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  parentPath: number[] = [],\n  allIds: Set<string> = new Set<string>()\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !allIds.has(id),\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n    allIds.add(id);\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = { ...route, id };\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        id,\n        children: route.children\n          ? convertRoutesToDataRoutes(route.children, treePath, allIds)\n          : undefined,\n      };\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch<string, RouteObjectType>(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n\n  return matches;\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  let flattenRoute = (\n    route: RouteObjectType,\n    index: number,\n    relativePath?: string\n  ) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath:\n        relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta,\n    });\n  };\n  routes.forEach((route, index) => {\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path: string): string[] {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n\n  let result: string[] = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explodes _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(\n    ...restExploded.map((subpath) =>\n      subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n\n  // Then if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map((exploded) =>\n    path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  originalPath: Path,\n  params: {\n    [key in PathParam<Path>]: string;\n  } = {} as any\n): string {\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were ` +\n        `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n        `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n        `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\") as Path;\n  }\n\n  return path\n    .replace(/^:(\\w+)/g, (_, key: PathParam<Path>) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/:(\\w+)/g, (_, key: PathParam<Path>) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return `/${params[key]!}`;\n    })\n    .replace(/(\\/?)\\*/, (_, prefix, __, str) => {\n      const star = \"*\" as PathParam<Path>;\n\n      if (params[star] == null) {\n        // If no splat was provided, trim the trailing slash _unless_ it's\n        // the entire path\n        return str === \"/*\" ? \"/\" : \"\";\n      }\n\n      // Apply the splat\n      return `${prefix}${params[star]}`;\n    });\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/\\/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"/([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURI(value: string) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * @private\n */\nexport function warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeys: Set<string | number> = new Set<string | number>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscriber?: (aborted: boolean) => void = undefined;\n  data: Record<string, unknown>;\n\n  constructor(data: Record<string, unknown>) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n  }\n\n  private trackPromise(\n    key: string | number,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.pendingKeys.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, null, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string | number,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeys.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    const subscriber = this.subscriber;\n    if (error) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      subscriber && subscriber(false);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    subscriber && subscriber(false);\n    return data;\n  }\n\n  subscribe(fn: (aborted: boolean) => void) {\n    this.subscriber = fn;\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeys.forEach((v, k) => this.pendingKeys.delete(k));\n    let subscriber = this.subscriber;\n    subscriber && subscriber(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeys.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport function defer(data: Record<string, unknown>) {\n  return new DeferredData(data);\n}\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nexport class ErrorResponse {\n  status: number;\n  statusText: string;\n  data: any;\n  error?: Error;\n  internal: boolean;\n\n  constructor(\n    status: number,\n    statusText: string | undefined,\n    data: any,\n    internal = false\n  ) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response throw from an action/loader\n */\nexport function isRouteErrorResponse(e: any): e is ErrorResponse {\n  return e instanceof ErrorResponse;\n}\n","import type { History, Location, Path, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  createClientSideURL,\n  invariant,\n  parsePath,\n} from \"./history\";\nimport type {\n  DataResult,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  DeferredResult,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  RedirectResult,\n  RouteData,\n  AgnosticRouteObject,\n  Submission,\n  SuccessResult,\n  AgnosticRouteMatch,\n  MutationFormMethod,\n} from \"./utils\";\nimport {\n  DeferredData,\n  ErrorResponse,\n  ResultType,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): void;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To, opts?: RouterNavigateOptions): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string,\n    opts?: RouterNavigateOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to URL encode a destination path according to the internal\n   * history implementation\n   * @param to\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key?: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key?: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  basename?: string;\n  routes: AgnosticRouteObject[];\n  history: History;\n  hydrationData?: HydrationState;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  basename: Router[\"basename\"];\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: { requestContext?: unknown }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: { routeId?: string; requestContext?: unknown }\n  ): Promise<any>;\n}\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (state: RouterState): void;\n}\n\ninterface UseMatchesMatch {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: unknown;\n  handle: unknown;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UseMatchesMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\n/**\n * Options for a navigate() call for a Link navigation\n */\ntype LinkNavigateOptions = {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n};\n\n/**\n * Options for a navigate() call for a Form navigation\n */\ntype SubmissionNavigateOptions = {\n  replace?: boolean;\n  state?: any;\n  formMethod?: FormMethod;\n  formEncType?: FormEncType;\n  formData: FormData;\n};\n\n/**\n * Options to pass to navigate() for either a Link or Form navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions =\n  | Omit<LinkNavigateOptions, \"replace\">\n  | Omit<SubmissionNavigateOptions, \"replace\">;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: FormMethod | undefined;\n    formAction: string | undefined;\n    formEncType: FormEncType | undefined;\n    formData: FormData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: FormMethod;\n    formAction: string;\n    formEncType: FormEncType;\n    formData: FormData;\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    data: TData | undefined;\n    \" _hasFetcherDoneAnything \"?: boolean;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: FormMethod | undefined;\n    formAction: string | undefined;\n    formEncType: FormEncType | undefined;\n    formData: FormData | undefined;\n    data: TData | undefined;\n    \" _hasFetcherDoneAnything \"?: boolean;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: FormMethod;\n    formAction: string;\n    formEncType: FormEncType;\n    formData: FormData;\n    data: TData | undefined;\n    \" _hasFetcherDoneAnything \"?: boolean;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Error thrown from the current action, keyed by the route containing the\n   * error boundary to render the error.  To be committed to the state after\n   * loaders have completed\n   */\n  pendingActionError?: RouteData;\n  /**\n   * Data returned from the current action, keyed by the route owning the action.\n   * To be committed to the state after loaders have completed\n   */\n  pendingActionData?: RouteData;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Tuple of [key, href, DataRouteMatch, DataRouteMatch[]] for a revalidating\n * fetcher.load()\n */\ntype RevalidatingFetcher = [\n  string,\n  string,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteMatch[]\n];\n\n/**\n * Tuple of [href, DataRouteMatch, DataRouteMatch[]] for an active\n * fetcher.load()\n */\ntype FetchLoadMatch = [\n  string,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteMatch[]\n];\n\n/**\n * Wrapper object to allow us to throw any response out from callLoaderOrAction\n * for queryRouter while preserving whether or not it was thrown or returned\n * from the loader/action\n */\ninterface QueryRouteResponse {\n  type: ResultType.data | ResultType.error;\n  response: Response;\n}\n\nconst validMutationMethodsArr: MutationFormMethod[] = [\n  \"post\",\n  \"put\",\n  \"patch\",\n  \"delete\",\n];\nconst validMutationMethods = new Set<MutationFormMethod>(\n  validMutationMethodsArr\n);\n\nconst validRequestMethodsArr: FormMethod[] = [\n  \"get\",\n  ...validMutationMethodsArr,\n];\nconst validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);\n\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n};\n\nconst isBrowser =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\";\nconst isServer = !isBrowser;\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let dataRoutes = convertRoutesToDataRoutes(init.routes);\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n\n  let initialMatches = matchRoutes(\n    dataRoutes,\n    init.history.location,\n    init.basename\n  );\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname,\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized =\n    !initialMatches.some((m) => m.route.loader) || init.hydrationData != null;\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidate()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n  // Fetchers that triggered redirect navigations from their actions\n  let fetchRedirectIds = new Set<string>();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location }) =>\n        startNavigation(historyAction, location)\n    );\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location);\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(newState: Partial<RouterState>): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n    subscribers.forEach((subscriber) => subscriber(state));\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      isMutationMethod(state.navigation.formMethod) &&\n      state.navigation.state === \"loading\" &&\n      location.state?._isRedirect !== true;\n\n    let actionData: RouteData | null;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData\n      ? mergeLoaderData(\n          state.loaderData,\n          newState.loaderData,\n          newState.matches || [],\n          newState.errors\n        )\n      : state.loaderData;\n\n    updateState({\n      ...newState, // matches, errors, fetchers go through as-is\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      // Don't restore on submission navigations\n      restoreScrollPosition: state.navigation.formData\n        ? false\n        : getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset: pendingPreventScrollReset,\n    });\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(to, opts);\n\n    let location = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    location = {\n      ...location,\n      ...init.history.encodeLocation(location),\n    };\n\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n\n    let historyAction = HistoryAction.Push;\n\n    if (userReplace === true) {\n      historyAction = HistoryAction.Replace;\n    } else if (userReplace === false) {\n      // no-op\n    } else if (\n      submission != null &&\n      isMutationMethod(submission.formMethod) &&\n      submission.formAction === state.location.pathname + state.location.search\n    ) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = HistoryAction.Replace;\n    }\n\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    return await startNavigation(historyAction, location, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      submission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponse;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(dataRoutes, location, init.basename);\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error,\n        },\n      });\n      return;\n    }\n\n    // Short circuit if it's only a hash change\n    if (isHashChangeOnly(state.location, location)) {\n      completeNavigation(location, { matches });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionData: RouteData | undefined;\n    let pendingError: RouteData | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError,\n      };\n    } else if (\n      opts &&\n      opts.submission &&\n      isMutationMethod(opts.submission.formMethod)\n    ) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace }\n      );\n\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n\n      let navigation: NavigationStates[\"Loading\"] = {\n        state: \"loading\",\n        location,\n        ...opts.submission,\n      };\n      loadingNavigation = navigation;\n\n      // Create a GET request for the loaders\n      request = new Request(request.url, { signal: request.signal });\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.replace,\n      pendingActionData,\n      pendingError\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      ...(pendingActionData ? { actionData: pendingActionData } : {}),\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts?: { replace?: boolean }\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation: NavigationStates[\"Submitting\"] = {\n      state: \"submitting\",\n      location,\n      ...submission,\n    };\n    updateState({ navigation });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id,\n        }),\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        router.basename\n      );\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let replace: boolean;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace =\n          result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, { submission, replace });\n      return { shortCircuited: true };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: { [boundaryMatch.route.id]: result.error },\n      };\n    }\n\n    if (isDeferredResult(result)) {\n      throw new Error(\"defer() is not supported in actions\");\n    }\n\n    return {\n      pendingActionData: { [actionMatch.route.id]: result.data },\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    replace?: boolean,\n    pendingActionData?: RouteData,\n    pendingError?: RouteData\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation;\n    if (!loadingNavigation) {\n      let navigation: NavigationStates[\"Loading\"] = {\n        state: \"loading\",\n        location,\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        ...submission,\n      };\n      loadingNavigation = navigation;\n    }\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission\n      ? submission\n      : loadingNavigation.formMethod &&\n        loadingNavigation.formAction &&\n        loadingNavigation.formData &&\n        loadingNavigation.formEncType\n      ? {\n          formMethod: loadingNavigation.formMethod,\n          formAction: loadingNavigation.formAction,\n          formData: loadingNavigation.formData,\n          formEncType: loadingNavigation.formEncType,\n        }\n      : undefined;\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      state,\n      matches,\n      activeSubmission,\n      location,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      pendingActionData,\n      pendingError,\n      fetchLoadMatches\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      completeNavigation(location, {\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null,\n        ...(pendingActionData ? { actionData: pendingActionData } : {}),\n      });\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(([key]) => {\n        let fetcher = state.fetchers.get(key);\n        let revalidatingFetcher: FetcherStates[\"Loading\"] = {\n          state: \"loading\",\n          data: fetcher && fetcher.data,\n          formMethod: undefined,\n          formAction: undefined,\n          formEncType: undefined,\n          formData: undefined,\n          \" _hasFetcherDoneAnything \": true,\n        };\n        state.fetchers.set(key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState({\n        navigation: loadingNavigation,\n        ...(actionData\n          ? Object.keys(actionData).length === 0\n            ? { actionData: null }\n            : { actionData }\n          : {}),\n        ...(revalidatingFetchers.length > 0\n          ? { fetchers: new Map(state.fetchers) }\n          : {}),\n      });\n    }\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n    revalidatingFetchers.forEach(([key]) =>\n      fetchControllers.set(key, pendingNavigationController!)\n    );\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    revalidatingFetchers.forEach(([key]) => fetchControllers.delete(key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      await startRedirectNavigation(state, redirect, { replace });\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingError,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n\n    return {\n      loaderData,\n      errors,\n      ...(didAbortFetchLoads || revalidatingFetchers.length > 0\n        ? { fetchers: new Map(state.fetchers) }\n        : {}),\n    };\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n\n    let matches = matchRoutes(dataRoutes, href, init.basename);\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: href })\n      );\n      return;\n    }\n\n    let { path, submission } = normalizeNavigateOptions(href, opts, true);\n    let match = getTargetMatch(matches, path);\n\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, [path, match, matches]);\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId,\n      });\n      setFetcherError(key, routeId, error);\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher: FetcherStates[\"Submitting\"] = {\n      state: \"submitting\",\n      ...submission,\n      data: existingFetcher && existingFetcher.data,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    state.fetchers.set(key, fetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      path,\n      abortController.signal,\n      submission\n    );\n    fetchControllers.set(key, abortController);\n\n    let actionResult = await callLoaderOrAction(\n      \"action\",\n      fetchRequest,\n      match,\n      requestMatches,\n      router.basename\n    );\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      fetchRedirectIds.add(key);\n      let loadingFetcher: FetcherStates[\"Loading\"] = {\n        state: \"loading\",\n        ...submission,\n        data: undefined,\n        \" _hasFetcherDoneAnything \": true,\n      };\n      state.fetchers.set(key, loadingFetcher);\n      updateState({ fetchers: new Map(state.fetchers) });\n\n      return startRedirectNavigation(state, actionResult, {\n        isFetchActionRedirect: true,\n      });\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n\n    if (isDeferredResult(actionResult)) {\n      invariant(false, \"defer() is not supported in actions\");\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      nextLocation,\n      abortController.signal\n    );\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(dataRoutes, state.navigation.location, init.basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      data: actionResult.data,\n      ...submission,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      state,\n      matches,\n      submission,\n      nextLocation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      { [match.route.id]: actionResult.data },\n      undefined, // No need to send through errors since we short circuit above\n      fetchLoadMatches\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter(([staleKey]) => staleKey !== key)\n      .forEach(([staleKey]) => {\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher: FetcherStates[\"Loading\"] = {\n          state: \"loading\",\n          data: existingFetcher && existingFetcher.data,\n          formMethod: undefined,\n          formAction: undefined,\n          formEncType: undefined,\n          formData: undefined,\n          \" _hasFetcherDoneAnything \": true,\n        };\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        fetchControllers.set(staleKey, abortController);\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(([staleKey]) =>\n      fetchControllers.delete(staleKey)\n    );\n\n    let redirect = findRedirect(results);\n    if (redirect) {\n      return startRedirectNavigation(state, redirect);\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    let doneFetcher: FetcherStates[\"Idle\"] = {\n      state: \"idle\",\n      data: actionResult.data,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    state.fetchers.set(key, doneFetcher);\n\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        ...(didAbortFetchLoads ? { fetchers: new Map(state.fetchers) } : {}),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[],\n    submission?: Submission\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it's loading state\n    let loadingFetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      ...submission,\n      data: existingFetcher && existingFetcher.data,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    state.fetchers.set(key, loadingFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let result: DataResult = await callLoaderOrAction(\n      \"loader\",\n      fetchRequest,\n      match,\n      matches,\n      router.basename\n    );\n\n    // Deferred isn't supported or fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by ou our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      await startRedirectNavigation(state, result);\n      return;\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error,\n        },\n      });\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    let doneFetcher: FetcherStates[\"Idle\"] = {\n      state: \"idle\",\n      data: result.data,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    state.fetchers.set(key, doneFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    state: RouterState,\n    redirect: RedirectResult,\n    {\n      submission,\n      replace,\n      isFetchActionRedirect,\n    }: {\n      submission?: Submission;\n      replace?: boolean;\n      isFetchActionRedirect?: boolean;\n    } = {}\n  ) {\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n\n    let redirectLocation = createLocation(\n      state.location,\n      redirect.location,\n      // TODO: This can be removed once we get rid of useTransition in Remix v2\n      {\n        _isRedirect: true,\n        ...(isFetchActionRedirect ? { _isFetchActionRedirect: true } : {}),\n      }\n    );\n    invariant(\n      redirectLocation,\n      \"Expected a location on the redirect navigation\"\n    );\n\n    // Check if this an external redirect that goes to a new origin\n    if (typeof window?.location !== \"undefined\") {\n      let newOrigin = createClientSideURL(redirect.location).origin;\n      if (window.location.origin !== newOrigin) {\n        if (replace) {\n          window.location.replace(redirect.location);\n        } else {\n          window.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let { formMethod, formAction, formEncType, formData } = state.navigation;\n    if (!submission && formMethod && formAction && formData && formEncType) {\n      submission = {\n        formMethod,\n        formAction,\n        formEncType,\n        formData,\n      };\n    }\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    if (\n      redirectPreserveMethodStatusCodes.has(redirect.status) &&\n      submission &&\n      isMutationMethod(submission.formMethod)\n    ) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: {\n          ...submission,\n          formAction: redirect.location,\n        },\n      });\n    } else {\n      // Otherwise, we kick off a new loading navigation, preserving the\n      // submission info for the duration of this navigation\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation: {\n          state: \"loading\",\n          location: redirectLocation,\n          formMethod: submission ? submission.formMethod : undefined,\n          formAction: submission ? submission.formAction : undefined,\n          formEncType: submission ? submission.formEncType : undefined,\n          formData: submission ? submission.formData : undefined,\n        },\n      });\n    }\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\"loader\", request, match, matches, router.basename)\n      ),\n      ...fetchersToLoad.map(([, href, match, fetchMatches]) =>\n        callLoaderOrAction(\n          \"loader\",\n          createClientSideRequest(href, request.signal),\n          match,\n          fetchMatches,\n          router.basename\n        )\n      ),\n    ]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        request.signal,\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map(([, , match]) => match),\n        fetcherResults,\n        request.signal,\n        true\n      ),\n    ]);\n\n    return { results, loaderResults, fetcherResults };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function setFetcherError(key: string, routeId: string, error: any) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error,\n      },\n      fetchers: new Map(state.fetchers),\n    });\n  }\n\n  function deleteFetcher(key: string): void {\n    if (fetchControllers.has(key)) abortFetcher(key);\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher: FetcherStates[\"Idle\"] = {\n        state: \"idle\",\n        data: fetcher.data,\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        \" _hasFetcherDoneAnything \": true,\n      };\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): void {\n    let doneKeys = [];\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n      }\n    }\n    markFetchersDone(doneKeys);\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || ((location) => location.key);\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\n      let userMatches = matches.map((m) =>\n        createUseMatchesMatch(m, state.loaderData)\n      );\n      let key = getScrollRestorationKey(location, userMatches) || location.key;\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\n      let userMatches = matches.map((m) =>\n        createUseMatchesMatch(m, state.loaderData)\n      );\n      let key = getScrollRestorationKey(location, userMatches) || location.key;\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  router = {\n    get basename() {\n      return init.basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    encodeLocation: (to: To) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nexport function createStaticHandler(\n  routes: AgnosticRouteObject[],\n  opts?: {\n    basename?: string;\n  }\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n\n  let dataRoutes = convertRoutesToDataRoutes(routes);\n  let basename = (opts ? opts.basename : null) || \"/\";\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(\n    request: Request,\n    { requestContext }: { requestContext?: unknown } = {}\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let method = request.method.toLowerCase();\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"head\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n      };\n    }\n\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, basename, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(\n    request: Request,\n    {\n      routeId,\n      requestContext,\n    }: { requestContext?: unknown; routeId?: string } = {}\n  ): Promise<any> {\n    let url = new URL(request.url);\n    let method = request.method.toLowerCase();\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"head\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId,\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      match\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    let routeData = [result.actionData, result.loaderData].find((v) => v);\n    return Object.values(routeData || {})[0];\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        routeMatch\n      );\n      return isResponse(result)\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    requestContext: unknown,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    let result: DataResult;\n\n    if (!actionMatch.route.action) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id,\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        basename,\n        true,\n        isRouteRequest,\n        requestContext\n      );\n\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(`${method}() call aborted`);\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      throw new Error(\"defer() is not supported in actions\");\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n      };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        undefined,\n        {\n          [boundaryMatch.route.id]: result.error,\n        }\n      );\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal,\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n\n    return {\n      ...context,\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      actionHeaders: {\n        ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n      },\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch,\n    pendingActionError?: RouteData\n  ): Promise<\n    | Omit<\n        StaticHandlerContext,\n        \"location\" | \"basename\" | \"actionData\" | \"actionHeaders\"\n      >\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !routeMatch?.route.loader) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id,\n      });\n    }\n\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : getLoaderMatchesUntilBoundary(\n          matches,\n          Object.keys(pendingActionError || {})[0]\n        );\n    let matchesToLoad = requestMatches.filter((m) => m.route.loader);\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n      };\n    }\n\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          basename,\n          true,\n          isRouteRequest,\n          requestContext\n        )\n      ),\n    ]);\n\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(`${method}() call aborted`);\n    }\n\n    let executedLoaders = new Set<string>();\n    results.forEach((result, i) => {\n      executedLoaders.add(matchesToLoad[i].route.id);\n      // Can't do anything with these without the Remix side of things, so just\n      // cancel them for now\n      if (isDeferredResult(result)) {\n        result.deferredData.cancel();\n      }\n    });\n\n    // Process and commit output from loaders\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionError\n    );\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n\n    return {\n      ...context,\n      matches,\n    };\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\nfunction isSubmissionNavigation(\n  opts: RouterNavigateOptions\n): opts is SubmissionNavigateOptions {\n  return opts != null && \"formData\" in opts;\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  to: To,\n  opts?: RouterNavigateOptions,\n  isFetcher = false\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponse;\n} {\n  let path = typeof to === \"string\" ? to : createPath(to);\n\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod }),\n    };\n  }\n\n  // Create a Submission on non-GET navigations\n  let submission: Submission | undefined;\n  if (opts.formData) {\n    submission = {\n      formMethod: opts.formMethod || \"get\",\n      formAction: stripHashFromPath(path),\n      formEncType:\n        (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n      formData: opts.formData,\n    };\n\n    if (isMutationMethod(submission.formMethod)) {\n      return { path, submission };\n    }\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  try {\n    let searchParams = convertFormDataToSearchParams(opts.formData);\n    // Since fetcher GET submissions only run a single loader (as opposed to\n    // navigation GET submissions which run all loaders), we need to preserve\n    // any incoming ?index params\n    if (\n      isFetcher &&\n      parsedPath.search &&\n      hasNakedIndexQuery(parsedPath.search)\n    ) {\n      searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = `?${searchParams}`;\n  } catch (e) {\n    return {\n      path,\n      error: getInternalRouterError(400),\n    };\n  }\n\n  return { path: createPath(parsedPath), submission };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId?: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  pendingActionData?: RouteData,\n  pendingError?: RouteData,\n  fetchLoadMatches?: Map<string, FetchLoadMatch>\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingError\n    ? Object.values(pendingError)[0]\n    : pendingActionData\n    ? Object.values(pendingActionData)[0]\n    : undefined;\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter(\n    (match, index) =>\n      match.route.loader != null &&\n      (isNewLoader(state.loaderData, state.matches[index], match) ||\n        // If this route had a pending deferred cancelled it must be revalidated\n        cancelledDeferredRoutes.some((id) => id === match.route.id) ||\n        shouldRevalidateLoader(\n          state.location,\n          state.matches[index],\n          submission,\n          location,\n          match,\n          isRevalidationRequired,\n          actionResult\n        ))\n  );\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches &&\n    fetchLoadMatches.forEach(([href, match, fetchMatches], key) => {\n      // This fetcher was cancelled from a prior action submission - force reload\n      if (cancelledFetcherLoads.includes(key)) {\n        revalidatingFetchers.push([key, href, match, fetchMatches]);\n      } else if (isRevalidationRequired) {\n        let shouldRevalidate = shouldRevalidateLoader(\n          href,\n          match,\n          submission,\n          href,\n          match,\n          isRevalidationRequired,\n          actionResult\n        );\n        if (shouldRevalidate) {\n          revalidatingFetchers.push([key, href, match, fetchMatches]);\n        }\n      }\n    });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  currentLocation: string | Location,\n  currentMatch: AgnosticDataRouteMatch,\n  submission: Submission | undefined,\n  location: string | Location,\n  match: AgnosticDataRouteMatch,\n  isRevalidationRequired: boolean,\n  actionResult: DataResult | undefined\n) {\n  let currentUrl = createClientSideURL(currentLocation);\n  let currentParams = currentMatch.params;\n  let nextUrl = createClientSideURL(location);\n  let nextParams = match.params;\n\n  // This is the default implementation as to when we revalidate.  If the route\n  // provides it's own implementation, then we give them full control but\n  // provide this value so they can leverage it if needed after they check\n  // their own specific use cases\n  // Note that fetchers always provide the same current/next locations so the\n  // URL-based checks here don't apply to fetcher shouldRevalidate calls\n  let defaultShouldRevalidate =\n    isNewRouteInstance(currentMatch, match) ||\n    // Clicked the same link, resubmitted a GET form\n    currentUrl.toString() === nextUrl.toString() ||\n    // Search params affect all loaders\n    currentUrl.search !== nextUrl.search ||\n    // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate\n    isRevalidationRequired;\n\n  if (match.route.shouldRevalidate) {\n    let routeChoice = match.route.shouldRevalidate({\n      currentUrl,\n      currentParams,\n      nextUrl,\n      nextParams,\n      ...submission,\n      actionResult,\n      defaultShouldRevalidate,\n    });\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return defaultShouldRevalidate;\n}\n\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  matches: AgnosticDataRouteMatch[],\n  basename = \"/\",\n  isStaticRequest: boolean = false,\n  isRouteRequest: boolean = false,\n  requestContext?: unknown\n): Promise<DataResult> {\n  let resultType;\n  let result;\n\n  // Setup a promise we can race against so that abort signals short circuit\n  let reject: () => void;\n  let abortPromise = new Promise((_, r) => (reject = r));\n  let onReject = () => reject();\n  request.signal.addEventListener(\"abort\", onReject);\n\n  try {\n    let handler = match.route[type];\n    invariant<Function>(\n      handler,\n      `Could not find the ${type} to run on the \"${match.route.id}\" route`\n    );\n\n    result = await Promise.race([\n      handler({ request, params: match.params, context: requestContext }),\n      abortPromise,\n    ]);\n\n    invariant(\n      result !== undefined,\n      `You defined ${type === \"action\" ? \"an action\" : \"a loader\"} for route ` +\n        `\"${match.route.id}\" but didn't return anything from your \\`${type}\\` ` +\n        `function. Please return a value or \\`null\\`.`\n    );\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    request.signal.removeEventListener(\"abort\", onReject);\n  }\n\n  if (isResponse(result)) {\n    let status = result.status;\n\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(\n        location,\n        \"Redirects returned/thrown from loaders/actions must have a Location header\"\n      );\n\n      let isAbsolute =\n        /^[a-z+]+:\\/\\//i.test(location) || location.startsWith(\"//\");\n\n      // Support relative routing in internal redirects\n      if (!isAbsolute) {\n        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);\n        let routePathnames = getPathContributingMatches(activeMatches).map(\n          (match) => match.pathnameBase\n        );\n        let resolvedLocation = resolveTo(\n          location,\n          routePathnames,\n          new URL(request.url).pathname\n        );\n        invariant(\n          createPath(resolvedLocation),\n          `Unable to resolve redirect location: ${location}`\n        );\n\n        // Prepend the basename to the redirect location if we have one\n        if (basename) {\n          let path = resolvedLocation.pathname;\n          resolvedLocation.pathname =\n            path === \"/\" ? basename : joinPaths([basename, path]);\n        }\n\n        location = createPath(resolvedLocation);\n      }\n\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n      };\n    }\n\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (isRouteRequest) {\n      // eslint-disable-next-line no-throw-literal\n      throw {\n        type: resultType || ResultType.data,\n        response: result,\n      };\n    }\n\n    let data: any;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponse(status, result.statusText, data),\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (resultType === ResultType.error) {\n    return { type: resultType, error: result };\n  }\n\n  if (result instanceof DeferredData) {\n    return { type: ResultType.deferred, deferredData: result };\n  }\n\n  return { type: ResultType.data, data: result };\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = createClientSideURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType, formData } = submission;\n    init.method = formMethod.toUpperCase();\n    init.body =\n      formEncType === \"application/x-www-form-urlencoded\"\n        ? convertFormDataToSearchParams(formData)\n        : formData;\n  }\n\n  // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    invariant(\n      typeof value === \"string\",\n      'File inputs are not supported with encType \"application/x-www-form-urlencoded\", ' +\n        'please use \"multipart/form-data\" instead.'\n    );\n    searchParams.append(key, value);\n  }\n\n  return searchParams;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  activeDeferreds?: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n\n      errors = errors || {};\n\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else if (isDeferredResult(result)) {\n      activeDeferreds && activeDeferreds.set(id, result.deferredData);\n      loaderData[id] = result.deferredData.data;\n      // TODO: Add statusCode/headers once we wire up streaming in Remix\n    } else {\n      loaderData[id] = result.data;\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (\n        result.statusCode != null &&\n        result.statusCode !== 200 &&\n        !foundError\n      ) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingError,\n    activeDeferreds\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let [key, , match] = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      throw new Error(\"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      throw new Error(\"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher: FetcherStates[\"Idle\"] = {\n        state: \"idle\",\n        data: result.data,\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        \" _hasFetcherDoneAnything \": true,\n      };\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[],\n  errors: RouteData | null | undefined\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      } else {\n        // No-op - this is so we ignore existing data if we have a key in the\n        // incoming object with an undefined value, which is how we unset a prior\n        // loaderData if we encounter a loader error\n      }\n    } else if (loaderData[id] !== undefined) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(routes: AgnosticDataRouteObject[]): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-error-route__`,\n  };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n  };\n}\n\nfunction getInternalRouterError(\n  status: number,\n  {\n    pathname,\n    routeId,\n    method,\n  }: {\n    pathname?: string;\n    routeId?: string;\n    method?: string;\n  } = {}\n) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method} request to \"${pathname}\" but ` +\n        `did not provide a \\`loader\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else {\n      errorMessage = \"Cannot submit binary form data using GET\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method.toUpperCase()} request to \"${pathname}\" but ` +\n        `did not provide an \\`action\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n\n  return new ErrorResponse(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results: DataResult[]): RedirectResult | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return result;\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  return (\n    a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash\n  );\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nfunction isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!isResponse(result)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isQueryRouteResponse(obj: any): obj is QueryRouteResponse {\n  return (\n    obj &&\n    isResponse(obj.response) &&\n    (obj.type === ResultType.data || ResultType.error)\n  );\n}\n\nfunction isValidMethod(method: string): method is FormMethod {\n  return validRequestMethods.has(method as FormMethod);\n}\n\nfunction isMutationMethod(method?: string): method is MutationFormMethod {\n  return validMutationMethods.has(method as MutationFormMethod);\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  signal: AbortSignal,\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\n// Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction createUseMatchesMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UseMatchesMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id] as unknown,\n    handle: route.handle as unknown,\n  };\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n//#endregion\n","/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","import type { FormEncType, FormMethod } from \"@remix-run/router\";\nimport type { RelativeRoutingType } from \"react-router\";\n\nexport const defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\n\nexport function isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\n\nexport function isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\n\nexport function isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\n\nexport function isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n\ntype LimitedMouseEvent = Pick<\n  MouseEvent,\n  \"button\" | \"metaKey\" | \"altKey\" | \"ctrlKey\" | \"shiftKey\"\n>;\n\nfunction isModifiedEvent(event: LimitedMouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nexport function shouldProcessLinkClick(\n  event: LimitedMouseEvent,\n  target?: string\n) {\n  return (\n    event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n  );\n}\n\nexport type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(\n  init: URLSearchParamsInit = \"\"\n): URLSearchParams {\n  return new URLSearchParams(\n    typeof init === \"string\" ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams\n      ? init\n      : Object.keys(init).reduce((memo, key) => {\n          let value = init[key];\n          return memo.concat(\n            Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n          );\n        }, [] as ParamKeyValuePair[])\n  );\n}\n\nexport function getSearchParamsForLocation(\n  locationSearch: string,\n  defaultSearchParams: URLSearchParams\n) {\n  let searchParams = createSearchParams(locationSearch);\n\n  for (let key of defaultSearchParams.keys()) {\n    if (!searchParams.has(key)) {\n      defaultSearchParams.getAll(key).forEach((value) => {\n        searchParams.append(key, value);\n      });\n    }\n  }\n\n  return searchParams;\n}\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n\n  /**\n   * Determines whether the form action is relative to the route hierarchy or\n   * the pathname.  Use this if you want to opt out of navigating the route\n   * hierarchy and want to instead route based on /-delimited URL segments\n   */\n  relative?: RelativeRoutingType;\n}\n\nexport function getFormSubmissionInfo(\n  target:\n    | HTMLFormElement\n    | HTMLButtonElement\n    | HTMLInputElement\n    | FormData\n    | URLSearchParams\n    | { [name: string]: string }\n    | null,\n  defaultAction: string,\n  options: SubmitOptions\n): {\n  url: URL;\n  method: string;\n  encType: string;\n  formData: FormData;\n} {\n  let method: string;\n  let action: string;\n  let encType: string;\n  let formData: FormData;\n\n  if (isFormElement(target)) {\n    let submissionTrigger: HTMLButtonElement | HTMLInputElement = (\n      options as any\n    ).submissionTrigger;\n\n    method = options.method || target.getAttribute(\"method\") || defaultMethod;\n    action = options.action || target.getAttribute(\"action\") || defaultAction;\n    encType =\n      options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n\n    formData = new FormData(target);\n\n    if (submissionTrigger && submissionTrigger.name) {\n      formData.append(submissionTrigger.name, submissionTrigger.value);\n    }\n  } else if (\n    isButtonElement(target) ||\n    (isInputElement(target) &&\n      (target.type === \"submit\" || target.type === \"image\"))\n  ) {\n    let form = target.form;\n\n    if (form == null) {\n      throw new Error(\n        `Cannot submit a <button> or <input type=\"submit\"> without a <form>`\n      );\n    }\n\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n\n    method =\n      options.method ||\n      target.getAttribute(\"formmethod\") ||\n      form.getAttribute(\"method\") ||\n      defaultMethod;\n    action =\n      options.action ||\n      target.getAttribute(\"formaction\") ||\n      form.getAttribute(\"action\") ||\n      defaultAction;\n    encType =\n      options.encType ||\n      target.getAttribute(\"formenctype\") ||\n      form.getAttribute(\"enctype\") ||\n      defaultEncType;\n\n    formData = new FormData(form);\n\n    // Include name + value from a <button>, appending in case the button name\n    // matches an existing input name\n    if (target.name) {\n      formData.append(target.name, target.value);\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\n      `Cannot submit element that is not <form>, <button>, or ` +\n        `<input type=\"submit|image\">`\n    );\n  } else {\n    method = options.method || defaultMethod;\n    action = options.action || defaultAction;\n    encType = options.encType || defaultEncType;\n\n    if (target instanceof FormData) {\n      formData = target;\n    } else {\n      formData = new FormData();\n\n      if (target instanceof URLSearchParams) {\n        for (let [name, value] of target) {\n          formData.append(name, value);\n        }\n      } else if (target != null) {\n        for (let name of Object.keys(target)) {\n          formData.append(name, target[name]);\n        }\n      }\n    }\n  }\n\n  let { protocol, host } = window.location;\n  let url = new URL(action, `${protocol}//${host}`);\n\n  return { url, method: method.toLowerCase(), encType, formData };\n}\n","/**\n * NOTE: If you refactor this to split up the modules into separate files,\n * you'll need to update the rollup config for react-router-dom-v5-compat.\n */\nimport * as React from \"react\";\nimport type {\n  NavigateOptions,\n  RelativeRoutingType,\n  RouteObject,\n  To,\n} from \"react-router\";\nimport {\n  Router,\n  createPath,\n  useHref,\n  useLocation,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useResolvedPath,\n  UNSAFE_DataRouterContext as DataRouterContext,\n  UNSAFE_DataRouterStateContext as DataRouterStateContext,\n  UNSAFE_NavigationContext as NavigationContext,\n  UNSAFE_RouteContext as RouteContext,\n  UNSAFE_enhanceManualRouteObjects as enhanceManualRouteObjects,\n} from \"react-router\";\nimport type {\n  BrowserHistory,\n  Fetcher,\n  FormEncType,\n  FormMethod,\n  GetScrollRestorationKeyFunction,\n  HashHistory,\n  History,\n  HydrationState,\n  Router as RemixRouter,\n} from \"@remix-run/router\";\nimport {\n  createRouter,\n  createBrowserHistory,\n  createHashHistory,\n  invariant,\n  joinPaths,\n  ErrorResponse,\n} from \"@remix-run/router\";\n\nimport type {\n  SubmitOptions,\n  ParamKeyValuePair,\n  URLSearchParamsInit,\n} from \"./dom\";\nimport {\n  createSearchParams,\n  defaultMethod,\n  getFormSubmissionInfo,\n  getSearchParamsForLocation,\n  shouldProcessLinkClick,\n} from \"./dom\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Re-exports\n////////////////////////////////////////////////////////////////////////////////\n\nexport type {\n  FormEncType,\n  FormMethod,\n  GetScrollRestorationKeyFunction,\n  ParamKeyValuePair,\n  SubmitOptions,\n  URLSearchParamsInit,\n};\nexport { createSearchParams };\n\n// Note: Keep in sync with react-router exports!\nexport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  AwaitProps,\n  DataRouteMatch,\n  DataRouteObject,\n  Fetcher,\n  Hash,\n  IndexRouteObject,\n  IndexRouteProps,\n  JsonFunction,\n  LayoutRouteProps,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  Location,\n  MemoryRouterProps,\n  NavigateFunction,\n  NavigateOptions,\n  NavigateProps,\n  Navigation,\n  Navigator,\n  NonIndexRouteObject,\n  OutletProps,\n  Params,\n  ParamParseKey,\n  Path,\n  PathMatch,\n  Pathname,\n  PathPattern,\n  PathRouteProps,\n  RedirectFunction,\n  RelativeRoutingType,\n  RouteMatch,\n  RouteObject,\n  RouteProps,\n  RouterProps,\n  RouterProviderProps,\n  RoutesProps,\n  Search,\n  ShouldRevalidateFunction,\n  To,\n} from \"react-router\";\nexport {\n  AbortedDeferredError,\n  Await,\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  createMemoryRouter,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromElements,\n  defer,\n  isRouteErrorResponse,\n  generatePath,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  renderMatches,\n  resolvePath,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useHref,\n  useInRouterContext,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n} from \"react-router\";\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  UNSAFE_DataRouterContext,\n  UNSAFE_DataRouterStateContext,\n  UNSAFE_NavigationContext,\n  UNSAFE_LocationContext,\n  UNSAFE_RouteContext,\n  UNSAFE_enhanceManualRouteObjects,\n} from \"react-router\";\n//#endregion\n\ndeclare global {\n  var __staticRouterHydrationData: HydrationState | undefined;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Routers\n////////////////////////////////////////////////////////////////////////////////\n\nexport function createBrowserRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    hydrationData?: HydrationState;\n    window?: Window;\n  }\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    history: createBrowserHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes: enhanceManualRouteObjects(routes),\n  }).initialize();\n}\n\nexport function createHashRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    hydrationData?: HydrationState;\n    window?: Window;\n  }\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    history: createHashHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes: enhanceManualRouteObjects(routes),\n  }).initialize();\n}\n\nfunction parseHydrationData(): HydrationState | undefined {\n  let state = window?.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = {\n      ...state,\n      errors: deserializeErrors(state.errors),\n    };\n  }\n  return state;\n}\n\nfunction deserializeErrors(\n  errors: RemixRouter[\"state\"][\"errors\"]\n): RemixRouter[\"state\"][\"errors\"] {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized: RemixRouter[\"state\"][\"errors\"] = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponse(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      let error = new Error(val.message);\n      // Wipe away the client-side stack trace.  Nothing to fill it in with\n      // because we don't serialize SSR stack traces for security reasons\n      error.stack = \"\";\n      serialized[key] = error;\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n\nexport interface BrowserRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport function BrowserRouter({\n  basename,\n  children,\n  window,\n}: BrowserRouterProps) {\n  let historyRef = React.useRef<BrowserHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window, v5Compat: true });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HashRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nexport function HashRouter({ basename, children, window }: HashRouterProps) {\n  let historyRef = React.useRef<HashHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window, v5Compat: true });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HistoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  history: History;\n}\n\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter({ basename, children, history }: HistoryRouterProps) {\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nif (__DEV__) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n\nexport { HistoryRouter as unstable_HistoryRouter };\n\nexport interface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n  to: To;\n}\n\n/**\n * The public API for rendering a history-aware <a>.\n */\nexport const Link = React.forwardRef<HTMLAnchorElement, LinkProps>(\n  function LinkWithRef(\n    {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      ...rest\n    },\n    ref\n  ) {\n    let href = useHref(to, { relative });\n    let internalOnClick = useLinkClickHandler(to, {\n      replace,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n    });\n    function handleClick(\n      event: React.MouseEvent<HTMLAnchorElement, MouseEvent>\n    ) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n\n    return (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      <a\n        {...rest}\n        href={href}\n        onClick={reloadDocument ? onClick : handleClick}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  Link.displayName = \"Link\";\n}\n\nexport interface NavLinkProps\n  extends Omit<LinkProps, \"className\" | \"style\" | \"children\"> {\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean; isPending: boolean }) => React.ReactNode);\n  caseSensitive?: boolean;\n  className?:\n    | string\n    | ((props: {\n        isActive: boolean;\n        isPending: boolean;\n      }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: {\n        isActive: boolean;\n        isPending: boolean;\n      }) => React.CSSProperties | undefined);\n}\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nexport const NavLink = React.forwardRef<HTMLAnchorElement, NavLinkProps>(\n  function NavLinkWithRef(\n    {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      children,\n      ...rest\n    },\n    ref\n  ) {\n    let path = useResolvedPath(to, { relative: rest.relative });\n    let location = useLocation();\n    let routerState = React.useContext(DataRouterStateContext);\n    let { navigator } = React.useContext(NavigationContext);\n\n    let toPathname = navigator.encodeLocation\n      ? navigator.encodeLocation(path).pathname\n      : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname =\n      routerState && routerState.navigation && routerState.navigation.location\n        ? routerState.navigation.location.pathname\n        : null;\n\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname\n        ? nextLocationPathname.toLowerCase()\n        : null;\n      toPathname = toPathname.toLowerCase();\n    }\n\n    let isActive =\n      locationPathname === toPathname ||\n      (!end &&\n        locationPathname.startsWith(toPathname) &&\n        locationPathname.charAt(toPathname.length) === \"/\");\n\n    let isPending =\n      nextLocationPathname != null &&\n      (nextLocationPathname === toPathname ||\n        (!end &&\n          nextLocationPathname.startsWith(toPathname) &&\n          nextLocationPathname.charAt(toPathname.length) === \"/\"));\n\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n\n    let className: string | undefined;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp({ isActive, isPending });\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null,\n      ]\n        .filter(Boolean)\n        .join(\" \");\n    }\n\n    let style =\n      typeof styleProp === \"function\"\n        ? styleProp({ isActive, isPending })\n        : styleProp;\n\n    return (\n      <Link\n        {...rest}\n        aria-current={ariaCurrent}\n        className={className}\n        ref={ref}\n        style={style}\n        to={to}\n      >\n        {typeof children === \"function\"\n          ? children({ isActive, isPending })\n          : children}\n      </Link>\n    );\n  }\n);\n\nif (__DEV__) {\n  NavLink.displayName = \"NavLink\";\n}\n\nexport interface FormProps extends React.FormHTMLAttributes<HTMLFormElement> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  /**\n   * Determines whether the form action is relative to the route hierarchy or\n   * the pathname.  Use this if you want to opt out of navigating the route\n   * hierarchy and want to instead route based on /-delimited URL segments\n   */\n  relative?: RelativeRoutingType;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not do anything.\n   */\n  onSubmit?: React.FormEventHandler<HTMLFormElement>;\n}\n\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nexport const Form = React.forwardRef<HTMLFormElement, FormProps>(\n  (props, ref) => {\n    return <FormImpl {...props} ref={ref} />;\n  }\n);\n\nif (__DEV__) {\n  Form.displayName = \"Form\";\n}\n\ntype HTMLSubmitEvent = React.BaseSyntheticEvent<\n  SubmitEvent,\n  Event,\n  HTMLFormElement\n>;\n\ntype HTMLFormSubmitter = HTMLButtonElement | HTMLInputElement;\n\ninterface FormImplProps extends FormProps {\n  fetcherKey?: string;\n  routeId?: string;\n}\n\nconst FormImpl = React.forwardRef<HTMLFormElement, FormImplProps>(\n  (\n    {\n      reloadDocument,\n      replace,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      fetcherKey,\n      routeId,\n      relative,\n      ...props\n    },\n    forwardedRef\n  ) => {\n    let submit = useSubmitImpl(fetcherKey, routeId);\n    let formMethod: FormMethod =\n      method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = useFormAction(action, { relative });\n    let submitHandler: React.FormEventHandler<HTMLFormElement> = (event) => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n\n      let submitter = (event as unknown as HTMLSubmitEvent).nativeEvent\n        .submitter as HTMLFormSubmitter | null;\n\n      let submitMethod =\n        (submitter?.getAttribute(\"formmethod\") as FormMethod | undefined) ||\n        method;\n\n      submit(submitter || event.currentTarget, {\n        method: submitMethod,\n        replace,\n        relative,\n      });\n    };\n\n    return (\n      <form\n        ref={forwardedRef}\n        method={formMethod}\n        action={formAction}\n        onSubmit={reloadDocument ? onSubmit : submitHandler}\n        {...props}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  FormImpl.displayName = \"FormImpl\";\n}\n\nexport interface ScrollRestorationProps {\n  getKey?: GetScrollRestorationKeyFunction;\n  storageKey?: string;\n}\n\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nexport function ScrollRestoration({\n  getKey,\n  storageKey,\n}: ScrollRestorationProps) {\n  useScrollRestoration({ getKey, storageKey });\n  return null;\n}\n\nif (__DEV__) {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\n\nenum DataRouterHook {\n  UseScrollRestoration = \"useScrollRestoration\",\n  UseSubmitImpl = \"useSubmitImpl\",\n  UseFetcher = \"useFetcher\",\n}\n\nenum DataRouterStateHook {\n  UseFetchers = \"useFetchers\",\n  UseScrollRestoration = \"useScrollRestoration\",\n}\n\nfunction getDataRouterConsoleError(\n  hookName: DataRouterHook | DataRouterStateHook\n) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.`;\n}\n\nfunction useDataRouterContext(hookName: DataRouterHook) {\n  let ctx = React.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\n\nfunction useDataRouterState(hookName: DataRouterStateHook) {\n  let state = React.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\n\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nexport function useLinkClickHandler<E extends Element = HTMLAnchorElement>(\n  to: To,\n  {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n  }: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n    preventScrollReset?: boolean;\n    relative?: RelativeRoutingType;\n  } = {}\n): (event: React.MouseEvent<E, MouseEvent>) => void {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, { relative });\n\n  return React.useCallback(\n    (event: React.MouseEvent<E, MouseEvent>) => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here unless the replace prop is explicitly set\n        let replace =\n          replaceProp !== undefined\n            ? replaceProp\n            : createPath(location) === createPath(path);\n\n        navigate(to, { replace, state, preventScrollReset, relative });\n      }\n    },\n    [\n      location,\n      navigate,\n      path,\n      replaceProp,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      relative,\n    ]\n  );\n}\n\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nexport function useSearchParams(\n  defaultInit?: URLSearchParamsInit\n): [URLSearchParams, SetURLSearchParams] {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not ` +\n      `support the URLSearchParams API. If you need to support Internet ` +\n      `Explorer 11, we recommend you load a polyfill such as ` +\n      `https://github.com/ungap/url-search-params\\n\\n` +\n      `If you're unsure how to load polyfills, we recommend you check out ` +\n      `https://polyfill.io/v3/ which provides some recommendations about how ` +\n      `to load polyfills only for users that need them, instead of for every ` +\n      `user.`\n  );\n\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n\n  let location = useLocation();\n  let searchParams = React.useMemo(\n    () =>\n      getSearchParamsForLocation(\n        location.search,\n        defaultSearchParamsRef.current\n      ),\n    [location.search]\n  );\n\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback<SetURLSearchParams>(\n    (nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(\n        typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit\n      );\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    },\n    [navigate, searchParams]\n  );\n\n  return [searchParams, setSearchParams];\n}\n\ntype SetURLSearchParams = (\n  nextInit?:\n    | URLSearchParamsInit\n    | ((prev: URLSearchParams) => URLSearchParamsInit),\n  navigateOpts?: NavigateOptions\n) => void;\n\ntype SubmitTarget =\n  | HTMLFormElement\n  | HTMLButtonElement\n  | HTMLInputElement\n  | FormData\n  | URLSearchParams\n  | { [name: string]: string }\n  | null;\n\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target: SubmitTarget,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nexport function useSubmit(): SubmitFunction {\n  return useSubmitImpl();\n}\n\nfunction useSubmitImpl(fetcherKey?: string, routeId?: string): SubmitFunction {\n  let { router } = useDataRouterContext(DataRouterHook.UseSubmitImpl);\n  let defaultAction = useFormAction();\n\n  return React.useCallback(\n    (target, options = {}) => {\n      if (typeof document === \"undefined\") {\n        throw new Error(\n          \"You are calling submit during the server render. \" +\n            \"Try calling submit within a `useEffect` or callback instead.\"\n        );\n      }\n\n      let { method, encType, formData, url } = getFormSubmissionInfo(\n        target,\n        defaultAction,\n        options\n      );\n\n      let href = url.pathname + url.search;\n      let opts = {\n        replace: options.replace,\n        formData,\n        formMethod: method as FormMethod,\n        formEncType: encType as FormEncType,\n      };\n      if (fetcherKey) {\n        invariant(routeId != null, \"No routeId available for useFetcher()\");\n        router.fetch(fetcherKey, routeId, href, opts);\n      } else {\n        router.navigate(href, opts);\n      }\n    },\n    [defaultAction, router, fetcherKey, routeId]\n  );\n}\n\nexport function useFormAction(\n  action?: string,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string {\n  let { basename } = React.useContext(NavigationContext);\n  let routeContext = React.useContext(RouteContext);\n  invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = { ...useResolvedPath(action ? action : \".\", { relative }) };\n\n  // Previously we set the default action to \".\". The problem with this is that\n  // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n  // URL. This is the intended behavior of when \".\" is specifically provided as\n  // the form action, but inconsistent w/ browsers when the action is omitted.\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to these directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    // or hash\n    path.search = location.search;\n    path.hash = location.hash;\n\n    // When grabbing search params from the URL, remove the automatically\n    // inserted ?index param so we match the useResolvedPath search behavior\n    // which would not include ?index\n    if (match.route.index) {\n      let params = new URLSearchParams(path.search);\n      params.delete(\"index\");\n      path.search = params.toString() ? `?${params.toString()}` : \"\";\n    }\n  }\n\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\nfunction createFetcherForm(fetcherKey: string, routeId: string) {\n  let FetcherForm = React.forwardRef<HTMLFormElement, FormProps>(\n    (props, ref) => {\n      return (\n        <FormImpl\n          {...props}\n          ref={ref}\n          fetcherKey={fetcherKey}\n          routeId={routeId}\n        />\n      );\n    }\n  );\n  if (__DEV__) {\n    FetcherForm.displayName = \"fetcher.Form\";\n  }\n  return FetcherForm;\n}\n\nlet fetcherId = 0;\n\nexport type FetcherWithComponents<TData> = Fetcher<TData> & {\n  Form: ReturnType<typeof createFetcherForm>;\n  submit: (\n    target: SubmitTarget,\n    // Fetchers cannot replace because they are not navigation events\n    options?: Omit<SubmitOptions, \"replace\">\n  ) => void;\n  load: (href: string) => void;\n};\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nexport function useFetcher<TData = any>(): FetcherWithComponents<TData> {\n  let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useFetcher must be used inside a RouteContext`);\n\n  let routeId = route.matches[route.matches.length - 1]?.route.id;\n  invariant(\n    routeId != null,\n    `useFetcher can only be used on routes that contain a unique \"id\"`\n  );\n\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => {\n    invariant(routeId, `No routeId available for fetcher.Form()`);\n    return createFetcherForm(fetcherKey, routeId);\n  });\n  let [load] = React.useState(() => (href: string) => {\n    invariant(router, \"No router available for fetcher.load()\");\n    invariant(routeId, \"No routeId available for fetcher.load()\");\n    router.fetch(fetcherKey, routeId, href);\n  });\n  let submit = useSubmitImpl(fetcherKey, routeId);\n\n  let fetcher = router.getFetcher<TData>(fetcherKey);\n\n  let fetcherWithComponents = React.useMemo(\n    () => ({\n      Form,\n      submit,\n      load,\n      ...fetcher,\n    }),\n    [fetcher, Form, submit, load]\n  );\n\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => {\n      if (!router) {\n        console.warn(`No fetcher available to clean up from useFetcher()`);\n        return;\n      }\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n\n  return fetcherWithComponents;\n}\n\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nexport function useFetchers(): Fetcher[] {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return [...state.fetchers.values()];\n}\n\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions: Record<string, number> = {};\n\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration({\n  getKey,\n  storageKey,\n}: {\n  getKey?: GetScrollRestorationKeyFunction;\n  storageKey?: string;\n} = {}) {\n  let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let { restoreScrollPosition, preventScrollReset } = useDataRouterState(\n    DataRouterStateHook.UseScrollRestoration\n  );\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n\n  // Save positions on unload\n  useBeforeUnload(\n    React.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = (getKey ? getKey(location, matches) : null) || location.key;\n        savedScrollPositions[key] = window.scrollY;\n      }\n      sessionStorage.setItem(\n        storageKey || SCROLL_RESTORATION_STORAGE_KEY,\n        JSON.stringify(savedScrollPositions)\n      );\n      window.history.scrollRestoration = \"auto\";\n    }, [storageKey, getKey, navigation.state, location, matches])\n  );\n\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        );\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let disableScrollRestoration = router?.enableScrollRestoration(\n        savedScrollPositions,\n        () => window.scrollY,\n        getKey\n      );\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, getKey]);\n\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(location.hash.slice(1));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n\n      // Opt out of scroll reset if this link requested it\n      if (preventScrollReset === true) {\n        return;\n      }\n\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nexport function useBeforeUnload(\n  callback: (event: BeforeUnloadEvent) => any\n): void {\n  React.useEffect(() => {\n    window.addEventListener(\"beforeunload\", callback);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback);\n    };\n  }, [callback]);\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Utils\n////////////////////////////////////////////////////////////////////////////////\n\nfunction warning(cond: boolean, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n//#endregion\n\nexport { useScrollRestoration as UNSAFE_useScrollRestoration };\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from \"react\";\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction isPolyfill(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  );\n}\n\nconst is: (x: any, y: any) => boolean =\n  typeof Object.is === \"function\" ? Object.is : isPolyfill;\n\n// Intentionally not using named imports because Rollup uses dynamic\n// dispatch for CommonJS interop named imports.\nconst { useState, useEffect, useLayoutEffect, useDebugValue } = React;\n\nlet didWarnOld18Alpha = false;\nlet didWarnUncachedGetSnapshot = false;\n\n// Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\nexport function useSyncExternalStore<T>(\n  subscribe: (fn: () => void) => () => void,\n  getSnapshot: () => T,\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  getServerSnapshot?: () => T\n): T {\n  if (__DEV__) {\n    if (!didWarnOld18Alpha) {\n      if (\"startTransition\" in React) {\n        didWarnOld18Alpha = true;\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that \" +\n            \"does not support useSyncExternalStore. The \" +\n            \"use-sync-external-store shim will not work correctly. Upgrade \" +\n            \"to a newer pre-release.\"\n        );\n      }\n    }\n  }\n\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedValue = getSnapshot();\n      if (!is(value, cachedValue)) {\n        console.error(\n          \"The result of getSnapshot should be cached to avoid an infinite loop\"\n        );\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{ inst }, forceUpdate] = useState({ inst: { value, getSnapshot } });\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  useLayoutEffect(() => {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot;\n\n    // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({ inst });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe, value, getSnapshot]);\n\n  useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({ inst });\n    }\n    const handleStoreChange = () => {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n    };\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe]);\n\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst: any) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n","/**\n * Inlined into the react-router repo since use-sync-external-store does not\n * provide a UMD-compatible package, so we need this to be able to distribute\n * UMD react-router bundles\n */\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from \"react\";\n\nimport { useSyncExternalStore as client } from \"./useSyncExternalStoreShimClient\";\nimport { useSyncExternalStore as server } from \"./useSyncExternalStoreShimServer\";\n\nconst canUseDOM: boolean = !!(\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n);\nconst isServerEnvironment = !canUseDOM;\nconst shim = isServerEnvironment ? server : client;\n\nexport const useSyncExternalStore =\n  \"useSyncExternalStore\" in React\n    ? ((module) => module.useSyncExternalStore)(React)\n    : shim;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport function useSyncExternalStore<T>(\n  subscribe: (fn: () => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T\n): T {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n","import * as React from \"react\";\nimport type {\n  AgnosticRouteMatch,\n  AgnosticIndexRouteObject,\n  AgnosticNonIndexRouteObject,\n  History,\n  Location,\n  Router,\n  StaticHandlerContext,\n  To,\n  TrackedPromise,\n} from \"@remix-run/router\";\nimport type { Action as NavigationType } from \"@remix-run/router\";\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nexport interface IndexRouteObject {\n  caseSensitive?: AgnosticIndexRouteObject[\"caseSensitive\"];\n  path?: AgnosticIndexRouteObject[\"path\"];\n  id?: AgnosticIndexRouteObject[\"id\"];\n  loader?: AgnosticIndexRouteObject[\"loader\"];\n  action?: AgnosticIndexRouteObject[\"action\"];\n  hasErrorBoundary?: AgnosticIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: AgnosticIndexRouteObject[\"shouldRevalidate\"];\n  handle?: AgnosticIndexRouteObject[\"handle\"];\n  index: true;\n  children?: undefined;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport interface NonIndexRouteObject {\n  caseSensitive?: AgnosticNonIndexRouteObject[\"caseSensitive\"];\n  path?: AgnosticNonIndexRouteObject[\"path\"];\n  id?: AgnosticNonIndexRouteObject[\"id\"];\n  loader?: AgnosticNonIndexRouteObject[\"loader\"];\n  action?: AgnosticNonIndexRouteObject[\"action\"];\n  hasErrorBoundary?: AgnosticNonIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: AgnosticNonIndexRouteObject[\"shouldRevalidate\"];\n  handle?: AgnosticNonIndexRouteObject[\"handle\"];\n  index?: false;\n  children?: RouteObject[];\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport type RouteObject = IndexRouteObject | NonIndexRouteObject;\n\nexport type DataRouteObject = RouteObject & {\n  children?: DataRouteObject[];\n  id: string;\n};\n\nexport interface RouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends RouteObject = RouteObject\n> extends AgnosticRouteMatch<ParamKey, RouteObjectType> {}\n\nexport interface DataRouteMatch extends RouteMatch<string, DataRouteObject> {}\n\nexport interface DataRouterContextObject extends NavigationContextObject {\n  router: Router;\n  staticContext?: StaticHandlerContext;\n}\n\nexport const DataRouterContext =\n  React.createContext<DataRouterContextObject | null>(null);\nif (__DEV__) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\n\nexport const DataRouterStateContext = React.createContext<\n  Router[\"state\"] | null\n>(null);\nif (__DEV__) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\n\nexport const AwaitContext = React.createContext<TrackedPromise | null>(null);\nif (__DEV__) {\n  AwaitContext.displayName = \"Await\";\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport interface Navigator {\n  createHref: History[\"createHref\"];\n  // Optional for backwards-compat with Router/HistoryRouter usage (edge case)\n  encodeLocation?: History[\"encodeLocation\"];\n  go: History[\"go\"];\n  push(to: To, state?: any, opts?: NavigateOptions): void;\n  replace(to: To, state?: any, opts?: NavigateOptions): void;\n}\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\nexport interface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n\nexport const RouteErrorContext = React.createContext<any>(null);\n\nif (__DEV__) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n","import * as React from \"react\";\nimport type {\n  Location,\n  ParamParseKey,\n  Params,\n  Path,\n  PathMatch,\n  PathPattern,\n  Router as RemixRouter,\n  To,\n} from \"@remix-run/router\";\nimport {\n  Action as NavigationType,\n  invariant,\n  isRouteErrorResponse,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  resolveTo,\n  warning,\n  UNSAFE_getPathContributingMatches as getPathContributingMatches,\n} from \"@remix-run/router\";\n\nimport type {\n  NavigateOptions,\n  RouteContextObject,\n  RouteMatch,\n  RouteObject,\n  DataRouteMatch,\n  RelativeRoutingType,\n} from \"./context\";\nimport {\n  DataRouterContext,\n  DataRouterStateContext,\n  LocationContext,\n  NavigationContext,\n  RouteContext,\n  RouteErrorContext,\n  AwaitContext,\n} from \"./context\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nexport function useHref(\n  to: To,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to, { relative });\n\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname =\n      pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    getPathContributingMatches(matches).map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        options.relative === \"path\"\n      );\n\n      // If we're operating within a basename, prepend it to the pathname prior\n      // to handing off to history.  If this is a root navigation, then we\n      // navigate to the raw basename which allows the basename to have full\n      // control over the presence of a trailing slash on root links\n      if (basename !== \"/\") {\n        path.pathname =\n          path.pathname === \"/\"\n            ? basename\n            : joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state,\n        options\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nexport function useResolvedPath(\n  to: To,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    getPathContributingMatches(matches).map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () =>\n      resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        relative === \"path\"\n      ),\n    [to, routePathnamesJson, locationPathname, relative]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { navigator } = React.useContext(NavigationContext);\n  let dataRouterStateContext = React.useContext(DataRouterStateContext);\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  let renderedMatches = _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([\n            parentPathnameBase,\n            // Re-encode pathnames that were decoded inside matchRoutes\n            navigator.encodeLocation\n              ? navigator.encodeLocation(match.pathname).pathname\n              : match.pathname,\n          ]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([\n                  parentPathnameBase,\n                  // Re-encode pathnames that were decoded inside matchRoutes\n                  navigator.encodeLocation\n                    ? navigator.encodeLocation(match.pathnameBase).pathname\n                    : match.pathnameBase,\n                ]),\n        })\n      ),\n    parentMatches,\n    dataRouterStateContext || undefined\n  );\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return (\n      <LocationContext.Provider\n        value={{\n          location: {\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\",\n            ...location,\n          },\n          navigationType: NavigationType.Pop,\n        }}\n      >\n        {renderedMatches}\n      </LocationContext.Provider>\n    );\n  }\n\n  return renderedMatches;\n}\n\nfunction DefaultErrorElement() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error)\n    ? `${error.status} ${error.statusText}`\n    : error instanceof Error\n    ? error.message\n    : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = { padding: \"0.5rem\", backgroundColor: lightgrey };\n  let codeStyles = { padding: \"2px 4px\", backgroundColor: lightgrey };\n  return (\n    <>\n      <h2>Unhandled Thrown Error!</h2>\n      <h3 style={{ fontStyle: \"italic\" }}>{message}</h3>\n      {stack ? <pre style={preStyles}>{stack}</pre> : null}\n      <p>💿 Hey developer 👋</p>\n      <p>\n        You can provide a way better UX than this when your app throws errors by\n        providing your own&nbsp;\n        <code style={codeStyles}>errorElement</code> props on&nbsp;\n        <code style={codeStyles}>&lt;Route&gt;</code>\n      </p>\n    </>\n  );\n}\n\ntype RenderErrorBoundaryProps = React.PropsWithChildren<{\n  location: Location;\n  error: any;\n  component: React.ReactNode;\n  routeContext: RouteContextObject;\n}>;\n\ntype RenderErrorBoundaryState = {\n  location: Location;\n  error: any;\n};\n\nexport class RenderErrorBoundary extends React.Component<\n  RenderErrorBoundaryProps,\n  RenderErrorBoundaryState\n> {\n  constructor(props: RenderErrorBoundaryProps) {\n    super(props);\n    this.state = {\n      location: props.location,\n      error: props.error,\n    };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { error: error };\n  }\n\n  static getDerivedStateFromProps(\n    props: RenderErrorBoundaryProps,\n    state: RenderErrorBoundaryState\n  ) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error,\n        location: props.location,\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n    };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error(\n      \"React Router caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n\n  render() {\n    return this.state.error ? (\n      <RouteContext.Provider value={this.props.routeContext}>\n        <RouteErrorContext.Provider\n          value={this.state.error}\n          children={this.props.component}\n        />\n      </RouteContext.Provider>\n    ) : (\n      this.props.children\n    );\n  }\n}\n\ninterface RenderedRouteProps {\n  routeContext: RouteContextObject;\n  match: RouteMatch<string, RouteObject>;\n  children: React.ReactNode | null;\n}\n\nfunction RenderedRoute({ routeContext, match, children }: RenderedRouteProps) {\n  let dataRouterContext = React.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (\n    dataRouterContext &&\n    dataRouterContext.static &&\n    dataRouterContext.staticContext &&\n    match.route.errorElement\n  ) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n\n  return (\n    <RouteContext.Provider value={routeContext}>\n      {children}\n    </RouteContext.Provider>\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = [],\n  dataRouterState?: RemixRouter[\"state\"]\n): React.ReactElement | null {\n  if (matches == null) {\n    if (dataRouterState?.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches as DataRouteMatch[];\n    } else {\n      return null;\n    }\n  }\n\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = dataRouterState?.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(\n      (m) => m.route.id && errors?.[m.route.id]\n    );\n    invariant(\n      errorIndex >= 0,\n      `Could not find a matching route for the current errors: ${errors}`\n    );\n    renderedMatches = renderedMatches.slice(\n      0,\n      Math.min(renderedMatches.length, errorIndex + 1)\n    );\n  }\n\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors?.[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement = dataRouterState\n      ? match.route.errorElement || <DefaultErrorElement />\n      : null;\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => (\n      <RenderedRoute match={match} routeContext={{ outlet, matches }}>\n        {error\n          ? errorElement\n          : match.route.element !== undefined\n          ? match.route.element\n          : outlet}\n      </RenderedRoute>\n    );\n    // Only wrap in an error boundary within data router usages when we have an\n    // errorElement on this route.  Otherwise let it bubble up to an ancestor\n    // errorElement\n    return dataRouterState && (match.route.errorElement || index === 0) ? (\n      <RenderErrorBoundary\n        location={dataRouterState.location}\n        component={errorElement}\n        error={error}\n        children={getChildren()}\n        routeContext={{ outlet: null, matches }}\n      />\n    ) : (\n      getChildren()\n    );\n  }, null as React.ReactElement | null);\n}\n\nenum DataRouterHook {\n  UseRevalidator = \"useRevalidator\",\n}\n\nenum DataRouterStateHook {\n  UseLoaderData = \"useLoaderData\",\n  UseActionData = \"useActionData\",\n  UseRouteError = \"useRouteError\",\n  UseNavigation = \"useNavigation\",\n  UseRouteLoaderData = \"useRouteLoaderData\",\n  UseMatches = \"useMatches\",\n  UseRevalidator = \"useRevalidator\",\n}\n\nfunction getDataRouterConsoleError(\n  hookName: DataRouterHook | DataRouterStateHook\n) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.`;\n}\n\nfunction useDataRouterContext(hookName: DataRouterHook) {\n  let ctx = React.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\n\nfunction useDataRouterState(hookName: DataRouterStateHook) {\n  let state = React.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\n\nfunction useRouteContext(hookName: DataRouterStateHook) {\n  let route = React.useContext(RouteContext);\n  invariant(route, getDataRouterConsoleError(hookName));\n  return route;\n}\n\nfunction useCurrentRouteId(hookName: DataRouterStateHook) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  invariant(\n    thisRoute.route.id,\n    `${hookName} can only be used on routes that contain a unique \"id\"`\n  );\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nexport function useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nexport function useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return {\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation,\n  };\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nexport function useMatches() {\n  let { matches, loaderData } = useDataRouterState(\n    DataRouterStateHook.UseMatches\n  );\n  return React.useMemo(\n    () =>\n      matches.map((match) => {\n        let { pathname, params } = match;\n        // Note: This structure matches that created by createUseMatchesMatch\n        // in the @remix-run/router , so if you change this please also change\n        // that :)  Eventually we'll DRY this up\n        return {\n          id: match.route.id,\n          pathname,\n          params,\n          data: loaderData[match.route.id] as unknown,\n          handle: match.route.handle as unknown,\n        };\n      }),\n    [matches, loaderData]\n  );\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nexport function useLoaderData(): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\n      `You cannot \\`useLoaderData\\` in an errorElement (routeId: ${routeId})`\n    );\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nexport function useRouteLoaderData(routeId: string): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nexport function useActionData(): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useActionData must be used inside a RouteContext`);\n\n  return Object.values(state?.actionData || {})[0];\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * errorElement to display a proper error message.\n */\nexport function useRouteError(): unknown {\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return state.errors?.[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */\nexport function useAsyncValue(): unknown {\n  let value = React.useContext(AwaitContext);\n  return value?._data;\n}\n\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */\nexport function useAsyncError(): unknown {\n  let value = React.useContext(AwaitContext);\n  return value?._error;\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\n\nfunction warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n","import * as React from \"react\";\nimport type {\n  TrackedPromise,\n  InitialEntry,\n  Location,\n  MemoryHistory,\n  Router as RemixRouter,\n  RouterState,\n  To,\n} from \"@remix-run/router\";\nimport {\n  Action as NavigationType,\n  AbortedDeferredError,\n  createMemoryHistory,\n  invariant,\n  parsePath,\n  stripBasename,\n  warning,\n} from \"@remix-run/router\";\nimport { useSyncExternalStore as useSyncExternalStoreShim } from \"./use-sync-external-store-shim\";\n\nimport type {\n  DataRouteObject,\n  IndexRouteObject,\n  RouteMatch,\n  RouteObject,\n  Navigator,\n  NonIndexRouteObject,\n  RelativeRoutingType,\n} from \"./context\";\nimport {\n  LocationContext,\n  NavigationContext,\n  DataRouterContext,\n  DataRouterStateContext,\n  AwaitContext,\n} from \"./context\";\nimport {\n  useAsyncValue,\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n} from \"./hooks\";\n\nexport interface RouterProviderProps {\n  fallbackElement?: React.ReactNode;\n  router: RemixRouter;\n}\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nexport function RouterProvider({\n  fallbackElement,\n  router,\n}: RouterProviderProps): React.ReactElement {\n  // Sync router state to our component state to force re-renders\n  let state: RouterState = useSyncExternalStoreShim(\n    router.subscribe,\n    () => router.state,\n    // We have to provide this so React@18 doesn't complain during hydration,\n    // but we pass our serialized hydration data into the router so state here\n    // is already synced with what the server saw\n    () => router.state\n  );\n\n  let navigator = React.useMemo((): Navigator => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state, opts) =>\n        router.navigate(to, {\n          state,\n          preventScrollReset: opts?.preventScrollReset,\n        }),\n      replace: (to, state, opts) =>\n        router.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts?.preventScrollReset,\n        }),\n    };\n  }, [router]);\n\n  let basename = router.basename || \"/\";\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return (\n    <>\n      <DataRouterContext.Provider\n        value={{\n          router,\n          navigator,\n          static: false,\n          // Do we need this?\n          basename,\n        }}\n      >\n        <DataRouterStateContext.Provider value={state}>\n          <Router\n            basename={router.basename}\n            location={router.state.location}\n            navigationType={router.state.historyAction}\n            navigator={navigator}\n          >\n            {router.state.initialized ? <Routes /> : fallbackElement}\n          </Router>\n        </DataRouterStateContext.Provider>\n      </DataRouterContext.Provider>\n      {null}\n    </>\n  );\n}\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true,\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n  relative?: RelativeRoutingType;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nexport function Navigate({\n  to,\n  replace,\n  state,\n  relative,\n}: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let dataRouterState = React.useContext(DataRouterStateContext);\n  let navigate = useNavigate();\n\n  React.useEffect(() => {\n    // Avoid kicking off multiple navigations if we're in the middle of a\n    // data-router navigation, since components get re-rendered when we enter\n    // a submitting/loading state\n    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n      return;\n    }\n    navigate(to, { replace, state, relative });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: NonIndexRouteObject[\"caseSensitive\"];\n  path?: NonIndexRouteObject[\"path\"];\n  id?: NonIndexRouteObject[\"id\"];\n  loader?: NonIndexRouteObject[\"loader\"];\n  action?: NonIndexRouteObject[\"action\"];\n  hasErrorBoundary?: NonIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: NonIndexRouteObject[\"shouldRevalidate\"];\n  handle?: NonIndexRouteObject[\"handle\"];\n  index?: false;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport interface LayoutRouteProps extends PathRouteProps {}\n\nexport interface IndexRouteProps {\n  caseSensitive?: IndexRouteObject[\"caseSensitive\"];\n  path?: IndexRouteObject[\"path\"];\n  id?: IndexRouteObject[\"id\"];\n  loader?: IndexRouteObject[\"loader\"];\n  action?: IndexRouteObject[\"action\"];\n  hasErrorBoundary?: IndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: IndexRouteObject[\"shouldRevalidate\"];\n  handle?: IndexRouteObject[\"handle\"];\n  index: true;\n  children?: undefined;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport type RouteProps = PathRouteProps | LayoutRouteProps | IndexRouteProps;\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nexport function Route(_props: RouteProps): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  let dataRouterContext = React.useContext(DataRouterContext);\n  // When in a DataRouterContext _without_ children, we use the router routes\n  // directly.  If we have children, then we're in a descendant tree and we\n  // need to use child routes.\n  let routes =\n    dataRouterContext && !children\n      ? (dataRouterContext.router.routes as DataRouteObject[])\n      : createRoutesFromChildren(children);\n  return useRoutes(routes, location);\n}\n\nexport interface AwaitResolveRenderFunction {\n  (data: Awaited<any>): React.ReactElement;\n}\n\nexport interface AwaitProps {\n  children: React.ReactNode | AwaitResolveRenderFunction;\n  errorElement?: React.ReactNode;\n  resolve: TrackedPromise | any;\n}\n\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nexport function Await({ children, errorElement, resolve }: AwaitProps) {\n  return (\n    <AwaitErrorBoundary resolve={resolve} errorElement={errorElement}>\n      <ResolveAwait>{children}</ResolveAwait>\n    </AwaitErrorBoundary>\n  );\n}\n\ntype AwaitErrorBoundaryProps = React.PropsWithChildren<{\n  errorElement?: React.ReactNode;\n  resolve: TrackedPromise | any;\n}>;\n\ntype AwaitErrorBoundaryState = {\n  error: any;\n};\n\nenum AwaitRenderStatus {\n  pending,\n  success,\n  error,\n}\n\nconst neverSettledPromise = new Promise(() => {});\n\nclass AwaitErrorBoundary extends React.Component<\n  AwaitErrorBoundaryProps,\n  AwaitErrorBoundaryState\n> {\n  constructor(props: AwaitErrorBoundaryProps) {\n    super(props);\n    this.state = { error: null };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { error };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error(\n      \"<Await> caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n\n  render() {\n    let { children, errorElement, resolve } = this.props;\n\n    let promise: TrackedPromise | null = null;\n    let status: AwaitRenderStatus = AwaitRenderStatus.pending;\n\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_data\", { get: () => resolve });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_error\", { get: () => renderError });\n    } else if ((resolve as TrackedPromise)._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status =\n        promise._error !== undefined\n          ? AwaitRenderStatus.error\n          : promise._data !== undefined\n          ? AwaitRenderStatus.success\n          : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", { get: () => true });\n      promise = resolve.then(\n        (data: any) =>\n          Object.defineProperty(resolve, \"_data\", { get: () => data }),\n        (error: any) =>\n          Object.defineProperty(resolve, \"_error\", { get: () => error })\n      );\n    }\n\n    if (\n      status === AwaitRenderStatus.error &&\n      promise._error instanceof AbortedDeferredError\n    ) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return <AwaitContext.Provider value={promise} children={errorElement} />;\n    }\n\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return <AwaitContext.Provider value={promise} children={children} />;\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */\nfunction ResolveAwait({\n  children,\n}: {\n  children: React.ReactNode | AwaitResolveRenderFunction;\n}) {\n  let data = useAsyncValue();\n  if (typeof children === \"function\") {\n    return children(data);\n  }\n  return <>{children}</>;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode,\n  parentPath: number[] = []\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element, index) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children, parentPath)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    invariant(\n      !element.props.index || !element.props.children,\n      \"An index route cannot have child routes.\"\n    );\n\n    let treePath = [...parentPath, index];\n    let route: RouteObject = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      hasErrorBoundary: element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(\n        element.props.children,\n        treePath\n      );\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n\n/**\n * @private\n * Walk the route tree and add hasErrorBoundary if it's not provided, so that\n * users providing manual route arrays can just specify errorElement\n */\nexport function enhanceManualRouteObjects(\n  routes: RouteObject[]\n): RouteObject[] {\n  return routes.map((route) => {\n    let routeClone = { ...route };\n    if (routeClone.hasErrorBoundary == null) {\n      routeClone.hasErrorBoundary = routeClone.errorElement != null;\n    }\n    if (routeClone.children) {\n      routeClone.children = enhanceManualRouteObjects(routeClone.children);\n    }\n    return routeClone;\n  });\n}\n","/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","var engine = require('../src/store-engine')\n\nvar storages = require('../storages/all')\nvar plugins = [require('../plugins/json2')]\n\nmodule.exports = engine.createStore(storages, plugins)\n","module.exports = json2Plugin\n\nfunction json2Plugin() {\n\trequire('./lib/json2')\n\treturn {}\n}\n","/* eslint-disable */\n\n//  json2.js\n//  2016-10-28\n//  Public Domain.\n//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n//  See http://www.JSON.org/js.html\n//  This code should be minified before deployment.\n//  See http://javascript.crockford.com/jsmin.html\n\n//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n//  NOT CONTROL.\n\n//  This file creates a global JSON object containing two methods: stringify\n//  and parse. This file provides the ES5 JSON capability to ES3 systems.\n//  If a project might run on IE8 or earlier, then this file should be included.\n//  This file does nothing on ES5 systems.\n\n//      JSON.stringify(value, replacer, space)\n//          value       any JavaScript value, usually an object or array.\n//          replacer    an optional parameter that determines how object\n//                      values are stringified for objects. It can be a\n//                      function or an array of strings.\n//          space       an optional parameter that specifies the indentation\n//                      of nested structures. If it is omitted, the text will\n//                      be packed without extra whitespace. If it is a number,\n//                      it will specify the number of spaces to indent at each\n//                      level. If it is a string (such as \"\\t\" or \"&nbsp;\"),\n//                      it contains the characters used to indent at each level.\n//          This method produces a JSON text from a JavaScript value.\n//          When an object value is found, if the object contains a toJSON\n//          method, its toJSON method will be called and the result will be\n//          stringified. A toJSON method does not serialize: it returns the\n//          value represented by the name/value pair that should be serialized,\n//          or undefined if nothing should be serialized. The toJSON method\n//          will be passed the key associated with the value, and this will be\n//          bound to the value.\n\n//          For example, this would serialize Dates as ISO strings.\n\n//              Date.prototype.toJSON = function (key) {\n//                  function f(n) {\n//                      // Format integers to have at least two digits.\n//                      return (n < 10)\n//                          ? \"0\" + n\n//                          : n;\n//                  }\n//                  return this.getUTCFullYear()   + \"-\" +\n//                       f(this.getUTCMonth() + 1) + \"-\" +\n//                       f(this.getUTCDate())      + \"T\" +\n//                       f(this.getUTCHours())     + \":\" +\n//                       f(this.getUTCMinutes())   + \":\" +\n//                       f(this.getUTCSeconds())   + \"Z\";\n//              };\n\n//          You can provide an optional replacer method. It will be passed the\n//          key and value of each member, with this bound to the containing\n//          object. The value that is returned from your method will be\n//          serialized. If your method returns undefined, then the member will\n//          be excluded from the serialization.\n\n//          If the replacer parameter is an array of strings, then it will be\n//          used to select the members to be serialized. It filters the results\n//          such that only members with keys listed in the replacer array are\n//          stringified.\n\n//          Values that do not have JSON representations, such as undefined or\n//          functions, will not be serialized. Such values in objects will be\n//          dropped; in arrays they will be replaced with null. You can use\n//          a replacer function to replace those with JSON values.\n\n//          JSON.stringify(undefined) returns undefined.\n\n//          The optional space parameter produces a stringification of the\n//          value that is filled with line breaks and indentation to make it\n//          easier to read.\n\n//          If the space parameter is a non-empty string, then that string will\n//          be used for indentation. If the space parameter is a number, then\n//          the indentation will be that many spaces.\n\n//          Example:\n\n//          text = JSON.stringify([\"e\", {pluribus: \"unum\"}]);\n//          // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n//          text = JSON.stringify([\"e\", {pluribus: \"unum\"}], null, \"\\t\");\n//          // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n//          text = JSON.stringify([new Date()], function (key, value) {\n//              return this[key] instanceof Date\n//                  ? \"Date(\" + this[key] + \")\"\n//                  : value;\n//          });\n//          // text is '[\"Date(---current time---)\"]'\n\n//      JSON.parse(text, reviver)\n//          This method parses a JSON text to produce an object or array.\n//          It can throw a SyntaxError exception.\n\n//          The optional reviver parameter is a function that can filter and\n//          transform the results. It receives each of the keys and values,\n//          and its return value is used instead of the original value.\n//          If it returns what it received, then the structure is not modified.\n//          If it returns undefined then the member is deleted.\n\n//          Example:\n\n//          // Parse the text. Values that look like ISO date strings will\n//          // be converted to Date objects.\n\n//          myData = JSON.parse(text, function (key, value) {\n//              var a;\n//              if (typeof value === \"string\") {\n//                  a =\n//   /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n//                  if (a) {\n//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n//                          +a[5], +a[6]));\n//                  }\n//              }\n//              return value;\n//          });\n\n//          myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n//              var d;\n//              if (typeof value === \"string\" &&\n//                      value.slice(0, 5) === \"Date(\" &&\n//                      value.slice(-1) === \")\") {\n//                  d = new Date(value.slice(5, -1));\n//                  if (d) {\n//                      return d;\n//                  }\n//              }\n//              return value;\n//          });\n\n//  This is a reference implementation. You are free to copy, modify, or\n//  redistribute.\n\n/*jslint\n    eval, for, this\n*/\n\n/*property\n    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== \"object\") {\n    JSON = {};\n}\n\n(function () {\n    \"use strict\";\n\n    var rx_one = /^[\\],:{}\\s]*$/;\n    var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\n    var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n    var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n    var rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    var rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10\n            ? \"0\" + n\n            : n;\n    }\n\n    function this_value() {\n        return this.valueOf();\n    }\n\n    if (typeof Date.prototype.toJSON !== \"function\") {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear() + \"-\" +\n                        f(this.getUTCMonth() + 1) + \"-\" +\n                        f(this.getUTCDate()) + \"T\" +\n                        f(this.getUTCHours()) + \":\" +\n                        f(this.getUTCMinutes()) + \":\" +\n                        f(this.getUTCSeconds()) + \"Z\"\n                : null;\n        };\n\n        Boolean.prototype.toJSON = this_value;\n        Number.prototype.toJSON = this_value;\n        String.prototype.toJSON = this_value;\n    }\n\n    var gap;\n    var indent;\n    var meta;\n    var rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        rx_escapable.lastIndex = 0;\n        return rx_escapable.test(string)\n            ? \"\\\"\" + string.replace(rx_escapable, function (a) {\n                var c = meta[a];\n                return typeof c === \"string\"\n                    ? c\n                    : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + \"\\\"\"\n            : \"\\\"\" + string + \"\\\"\";\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i;          // The loop counter.\n        var k;          // The member key.\n        var v;          // The member value.\n        var length;\n        var mind = gap;\n        var partial;\n        var value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === \"object\" &&\n                typeof value.toJSON === \"function\") {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === \"function\") {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case \"string\":\n            return quote(value);\n\n        case \"number\":\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value)\n                ? String(value)\n                : \"null\";\n\n        case \"boolean\":\n        case \"null\":\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce \"null\". The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is \"object\", we might be dealing with an object or an array or\n// null.\n\n        case \"object\":\n\n// Due to a specification blunder in ECMAScript, typeof null is \"object\",\n// so watch out for that case.\n\n            if (!value) {\n                return \"null\";\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || \"null\";\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? \"[]\"\n                    : gap\n                        ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\"\n                        : \"[\" + partial.join(\",\") + \"]\";\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === \"object\") {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === \"string\") {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap\n                                    ? \": \"\n                                    : \":\"\n                            ) + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap\n                                    ? \": \"\n                                    : \":\"\n                            ) + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? \"{}\"\n                : gap\n                    ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\"\n                    : \"{\" + partial.join(\",\") + \"}\";\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== \"function\") {\n        meta = {    // table of character substitutions\n            \"\\b\": \"\\\\b\",\n            \"\\t\": \"\\\\t\",\n            \"\\n\": \"\\\\n\",\n            \"\\f\": \"\\\\f\",\n            \"\\r\": \"\\\\r\",\n            \"\\\"\": \"\\\\\\\"\",\n            \"\\\\\": \"\\\\\\\\\"\n        };\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = \"\";\n            indent = \"\";\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === \"number\") {\n                for (i = 0; i < space; i += 1) {\n                    indent += \" \";\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === \"string\") {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== \"function\" &&\n                    (typeof replacer !== \"object\" ||\n                    typeof replacer.length !== \"number\")) {\n                throw new Error(\"JSON.stringify\");\n            }\n\n// Make a fake root object containing our value under the key of \"\".\n// Return the result of stringifying the value.\n\n            return str(\"\", {\"\": value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== \"function\") {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k;\n                var v;\n                var value = holder[key];\n                if (value && typeof value === \"object\") {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            rx_dangerous.lastIndex = 0;\n            if (rx_dangerous.test(text)) {\n                text = text.replace(rx_dangerous, function (a) {\n                    return \"\\\\u\" +\n                            (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with \"()\" and \"new\"\n// because they can cause invocation, and \"=\" because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with \"@\" (a non-JSON character). Second, we\n// replace all simple value tokens with \"]\" characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or \"]\" or\n// \",\" or \":\" or \"{\" or \"}\". If that is so, then the text is safe for eval.\n\n            if (\n                rx_one.test(\n                    text\n                        .replace(rx_two, \"@\")\n                        .replace(rx_three, \"]\")\n                        .replace(rx_four, \"\")\n                )\n            ) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The \"{\" operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval(\"(\" + text + \")\");\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return (typeof reviver === \"function\")\n                    ? walk({\"\": j}, \"\")\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError(\"JSON.parse\");\n        };\n    }\n}());","var util = require('./util')\nvar slice = util.slice\nvar pluck = util.pluck\nvar each = util.each\nvar bind = util.bind\nvar create = util.create\nvar isList = util.isList\nvar isFunction = util.isFunction\nvar isObject = util.isObject\n\nmodule.exports = {\n\tcreateStore: createStore\n}\n\nvar storeAPI = {\n\tversion: '2.0.12',\n\tenabled: false,\n\t\n\t// get returns the value of the given key. If that value\n\t// is undefined, it returns optionalDefaultValue instead.\n\tget: function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t},\n\n\t// set will store the given value at key and returns value.\n\t// Calling set with value === undefined is equivalent to calling remove.\n\tset: function(key, value) {\n\t\tif (value === undefined) {\n\t\t\treturn this.remove(key)\n\t\t}\n\t\tthis.storage.write(this._namespacePrefix + key, this._serialize(value))\n\t\treturn value\n\t},\n\n\t// remove deletes the key and value stored at the given key.\n\tremove: function(key) {\n\t\tthis.storage.remove(this._namespacePrefix + key)\n\t},\n\n\t// each will call the given callback once for each key-value pair\n\t// in this store.\n\teach: function(callback) {\n\t\tvar self = this\n\t\tthis.storage.each(function(val, namespacedKey) {\n\t\t\tcallback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))\n\t\t})\n\t},\n\n\t// clearAll will remove all the stored key-value pairs in this store.\n\tclearAll: function() {\n\t\tthis.storage.clearAll()\n\t},\n\n\t// additional functionality that can't live in plugins\n\t// ---------------------------------------------------\n\n\t// hasNamespace returns true if this store instance has the given namespace.\n\thasNamespace: function(namespace) {\n\t\treturn (this._namespacePrefix == '__storejs_'+namespace+'_')\n\t},\n\n\t// createStore creates a store.js instance with the first\n\t// functioning storage in the list of storage candidates,\n\t// and applies the the given mixins to the instance.\n\tcreateStore: function() {\n\t\treturn createStore.apply(this, arguments)\n\t},\n\t\n\taddPlugin: function(plugin) {\n\t\tthis._addPlugin(plugin)\n\t},\n\t\n\tnamespace: function(namespace) {\n\t\treturn createStore(this.storage, this.plugins, namespace)\n\t}\n}\n\nfunction _warn() {\n\tvar _console = (typeof console == 'undefined' ? null : console)\n\tif (!_console) { return }\n\tvar fn = (_console.warn ? _console.warn : _console.log)\n\tfn.apply(_console, arguments)\n}\n\nfunction createStore(storages, plugins, namespace) {\n\tif (!namespace) {\n\t\tnamespace = ''\n\t}\n\tif (storages && !isList(storages)) {\n\t\tstorages = [storages]\n\t}\n\tif (plugins && !isList(plugins)) {\n\t\tplugins = [plugins]\n\t}\n\n\tvar namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')\n\tvar namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)\n\tvar legalNamespaces = /^[a-zA-Z0-9_\\-]*$/ // alpha-numeric + underscore and dash\n\tif (!legalNamespaces.test(namespace)) {\n\t\tthrow new Error('store.js namespaces can only have alphanumerics + underscores and dashes')\n\t}\n\t\n\tvar _privateStoreProps = {\n\t\t_namespacePrefix: namespacePrefix,\n\t\t_namespaceRegexp: namespaceRegexp,\n\n\t\t_testStorage: function(storage) {\n\t\t\ttry {\n\t\t\t\tvar testStr = '__storejs__test__'\n\t\t\t\tstorage.write(testStr, testStr)\n\t\t\t\tvar ok = (storage.read(testStr) === testStr)\n\t\t\t\tstorage.remove(testStr)\n\t\t\t\treturn ok\n\t\t\t} catch(e) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t},\n\n\t\t_assignPluginFnProp: function(pluginFnProp, propName) {\n\t\t\tvar oldFn = this[propName]\n\t\t\tthis[propName] = function pluginFn() {\n\t\t\t\tvar args = slice(arguments, 0)\n\t\t\t\tvar self = this\n\n\t\t\t\t// super_fn calls the old function which was overwritten by\n\t\t\t\t// this mixin.\n\t\t\t\tfunction super_fn() {\n\t\t\t\t\tif (!oldFn) { return }\n\t\t\t\t\teach(arguments, function(arg, i) {\n\t\t\t\t\t\targs[i] = arg\n\t\t\t\t\t})\n\t\t\t\t\treturn oldFn.apply(self, args)\n\t\t\t\t}\n\n\t\t\t\t// Give mixing function access to super_fn by prefixing all mixin function\n\t\t\t\t// arguments with super_fn.\n\t\t\t\tvar newFnArgs = [super_fn].concat(args)\n\n\t\t\t\treturn pluginFnProp.apply(self, newFnArgs)\n\t\t\t}\n\t\t},\n\n\t\t_serialize: function(obj) {\n\t\t\treturn JSON.stringify(obj)\n\t\t},\n\n\t\t_deserialize: function(strVal, defaultVal) {\n\t\t\tif (!strVal) { return defaultVal }\n\t\t\t// It is possible that a raw string value has been previously stored\n\t\t\t// in a storage without using store.js, meaning it will be a raw\n\t\t\t// string value instead of a JSON serialized string. By defaulting\n\t\t\t// to the raw string value in case of a JSON parse error, we allow\n\t\t\t// for past stored values to be forwards-compatible with store.js\n\t\t\tvar val = ''\n\t\t\ttry { val = JSON.parse(strVal) }\n\t\t\tcatch(e) { val = strVal }\n\n\t\t\treturn (val !== undefined ? val : defaultVal)\n\t\t},\n\t\t\n\t\t_addStorage: function(storage) {\n\t\t\tif (this.enabled) { return }\n\t\t\tif (this._testStorage(storage)) {\n\t\t\t\tthis.storage = storage\n\t\t\t\tthis.enabled = true\n\t\t\t}\n\t\t},\n\n\t\t_addPlugin: function(plugin) {\n\t\t\tvar self = this\n\n\t\t\t// If the plugin is an array, then add all plugins in the array.\n\t\t\t// This allows for a plugin to depend on other plugins.\n\t\t\tif (isList(plugin)) {\n\t\t\t\teach(plugin, function(plugin) {\n\t\t\t\t\tself._addPlugin(plugin)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Keep track of all plugins we've seen so far, so that we\n\t\t\t// don't add any of them twice.\n\t\t\tvar seenPlugin = pluck(this.plugins, function(seenPlugin) {\n\t\t\t\treturn (plugin === seenPlugin)\n\t\t\t})\n\t\t\tif (seenPlugin) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.plugins.push(plugin)\n\n\t\t\t// Check that the plugin is properly formed\n\t\t\tif (!isFunction(plugin)) {\n\t\t\t\tthrow new Error('Plugins must be function values that return objects')\n\t\t\t}\n\n\t\t\tvar pluginProperties = plugin.call(this)\n\t\t\tif (!isObject(pluginProperties)) {\n\t\t\t\tthrow new Error('Plugins must return an object of function properties')\n\t\t\t}\n\n\t\t\t// Add the plugin function properties to this store instance.\n\t\t\teach(pluginProperties, function(pluginFnProp, propName) {\n\t\t\t\tif (!isFunction(pluginFnProp)) {\n\t\t\t\t\tthrow new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')\n\t\t\t\t}\n\t\t\t\tself._assignPluginFnProp(pluginFnProp, propName)\n\t\t\t})\n\t\t},\n\t\t\n\t\t// Put deprecated properties in the private API, so as to not expose it to accidential\n\t\t// discovery through inspection of the store object.\n\t\t\n\t\t// Deprecated: addStorage\n\t\taddStorage: function(storage) {\n\t\t\t_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')\n\t\t\tthis._addStorage(storage)\n\t\t}\n\t}\n\n\tvar store = create(_privateStoreProps, storeAPI, {\n\t\tplugins: []\n\t})\n\tstore.raw = {}\n\teach(store, function(prop, propName) {\n\t\tif (isFunction(prop)) {\n\t\t\tstore.raw[propName] = bind(store, prop)\t\t\t\n\t\t}\n\t})\n\teach(storages, function(storage) {\n\t\tstore._addStorage(storage)\n\t})\n\teach(plugins, function(plugin) {\n\t\tstore._addPlugin(plugin)\n\t})\n\treturn store\n}\n","var assign = make_assign()\nvar create = make_create()\nvar trim = make_trim()\nvar Global = (typeof window !== 'undefined' ? window : global)\n\nmodule.exports = {\n\tassign: assign,\n\tcreate: create,\n\ttrim: trim,\n\tbind: bind,\n\tslice: slice,\n\teach: each,\n\tmap: map,\n\tpluck: pluck,\n\tisList: isList,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tGlobal: Global\n}\n\nfunction make_assign() {\n\tif (Object.assign) {\n\t\treturn Object.assign\n\t} else {\n\t\treturn function shimAssign(obj, props1, props2, etc) {\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\teach(Object(arguments[i]), function(val, key) {\n\t\t\t\t\tobj[key] = val\n\t\t\t\t})\n\t\t\t}\t\t\t\n\t\t\treturn obj\n\t\t}\n\t}\n}\n\nfunction make_create() {\n\tif (Object.create) {\n\t\treturn function create(obj, assignProps1, assignProps2, etc) {\n\t\t\tvar assignArgsList = slice(arguments, 1)\n\t\t\treturn assign.apply(this, [Object.create(obj)].concat(assignArgsList))\n\t\t}\n\t} else {\n\t\tfunction F() {} // eslint-disable-line no-inner-declarations\n\t\treturn function create(obj, assignProps1, assignProps2, etc) {\n\t\t\tvar assignArgsList = slice(arguments, 1)\n\t\t\tF.prototype = obj\n\t\t\treturn assign.apply(this, [new F()].concat(assignArgsList))\n\t\t}\n\t}\n}\n\nfunction make_trim() {\n\tif (String.prototype.trim) {\n\t\treturn function trim(str) {\n\t\t\treturn String.prototype.trim.call(str)\n\t\t}\n\t} else {\n\t\treturn function trim(str) {\n\t\t\treturn str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '')\n\t\t}\n\t}\n}\n\nfunction bind(obj, fn) {\n\treturn function() {\n\t\treturn fn.apply(obj, Array.prototype.slice.call(arguments, 0))\n\t}\n}\n\nfunction slice(arr, index) {\n\treturn Array.prototype.slice.call(arr, index || 0)\n}\n\nfunction each(obj, fn) {\n\tpluck(obj, function(val, key) {\n\t\tfn(val, key)\n\t\treturn false\n\t})\n}\n\nfunction map(obj, fn) {\n\tvar res = (isList(obj) ? [] : {})\n\tpluck(obj, function(v, k) {\n\t\tres[k] = fn(v, k)\n\t\treturn false\n\t})\n\treturn res\n}\n\nfunction pluck(obj, fn) {\n\tif (isList(obj)) {\n\t\tfor (var i=0; i<obj.length; i++) {\n\t\t\tif (fn(obj[i], i)) {\n\t\t\t\treturn obj[i]\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var key in obj) {\n\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\tif (fn(obj[key], key)) {\n\t\t\t\t\treturn obj[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction isList(val) {\n\treturn (val != null && typeof val != 'function' && typeof val.length == 'number')\n}\n\nfunction isFunction(val) {\n\treturn val && {}.toString.call(val) === '[object Function]'\n}\n\nfunction isObject(val) {\n\treturn val && {}.toString.call(val) === '[object Object]'\n}\n","module.exports = [\n\t// Listed in order of usage preference\n\trequire('./localStorage'),\n\trequire('./oldFF-globalStorage'),\n\trequire('./oldIE-userDataStorage'),\n\trequire('./cookieStorage'),\n\trequire('./sessionStorage'),\n\trequire('./memoryStorage')\n]\n","// cookieStorage is useful Safari private browser mode, where localStorage\n// doesn't work but cookies do. This implementation is adopted from\n// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage\n\nvar util = require('../src/util')\nvar Global = util.Global\nvar trim = util.trim\n\nmodule.exports = {\n\tname: 'cookieStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar doc = Global.document\n\nfunction read(key) {\n\tif (!key || !_has(key)) { return null }\n\tvar regexpStr = \"(?:^|.*;\\\\s*)\" +\n\t\tescape(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") +\n\t\t\"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\"\n\treturn unescape(doc.cookie.replace(new RegExp(regexpStr), \"$1\"))\n}\n\nfunction each(callback) {\n\tvar cookies = doc.cookie.split(/; ?/g)\n\tfor (var i = cookies.length - 1; i >= 0; i--) {\n\t\tif (!trim(cookies[i])) {\n\t\t\tcontinue\n\t\t}\n\t\tvar kvp = cookies[i].split('=')\n\t\tvar key = unescape(kvp[0])\n\t\tvar val = unescape(kvp[1])\n\t\tcallback(val, key)\n\t}\n}\n\nfunction write(key, data) {\n\tif(!key) { return }\n\tdoc.cookie = escape(key) + \"=\" + escape(data) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\"\n}\n\nfunction remove(key) {\n\tif (!key || !_has(key)) {\n\t\treturn\n\t}\n\tdoc.cookie = escape(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\"\n}\n\nfunction clearAll() {\n\teach(function(_, key) {\n\t\tremove(key)\n\t})\n}\n\nfunction _has(key) {\n\treturn (new RegExp(\"(?:^|;\\\\s*)\" + escape(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie)\n}\n","var util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'localStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nfunction localStorage() {\n\treturn Global.localStorage\n}\n\nfunction read(key) {\n\treturn localStorage().getItem(key)\n}\n\nfunction write(key, data) {\n\treturn localStorage().setItem(key, data)\n}\n\nfunction each(fn) {\n\tfor (var i = localStorage().length - 1; i >= 0; i--) {\n\t\tvar key = localStorage().key(i)\n\t\tfn(read(key), key)\n\t}\n}\n\nfunction remove(key) {\n\treturn localStorage().removeItem(key)\n}\n\nfunction clearAll() {\n\treturn localStorage().clear()\n}\n","// memoryStorage is a useful last fallback to ensure that the store\n// is functions (meaning store.get(), store.set(), etc will all function).\n// However, stored values will not persist when the browser navigates to\n// a new page or reloads the current page.\n\nmodule.exports = {\n\tname: 'memoryStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar memoryStorage = {}\n\nfunction read(key) {\n\treturn memoryStorage[key]\n}\n\nfunction write(key, data) {\n\tmemoryStorage[key] = data\n}\n\nfunction each(callback) {\n\tfor (var key in memoryStorage) {\n\t\tif (memoryStorage.hasOwnProperty(key)) {\n\t\t\tcallback(memoryStorage[key], key)\n\t\t}\n\t}\n}\n\nfunction remove(key) {\n\tdelete memoryStorage[key]\n}\n\nfunction clearAll(key) {\n\tmemoryStorage = {}\n}\n","// oldFF-globalStorage provides storage for Firefox\n// versions 6 and 7, where no localStorage, etc\n// is available.\n\nvar util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'oldFF-globalStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar globalStorage = Global.globalStorage\n\nfunction read(key) {\n\treturn globalStorage[key]\n}\n\nfunction write(key, data) {\n\tglobalStorage[key] = data\n}\n\nfunction each(fn) {\n\tfor (var i = globalStorage.length - 1; i >= 0; i--) {\n\t\tvar key = globalStorage.key(i)\n\t\tfn(globalStorage[key], key)\n\t}\n}\n\nfunction remove(key) {\n\treturn globalStorage.removeItem(key)\n}\n\nfunction clearAll() {\n\teach(function(key, _) {\n\t\tdelete globalStorage[key]\n\t})\n}\n","// oldIE-userDataStorage provides storage for Internet Explorer\n// versions 6 and 7, where no localStorage, sessionStorage, etc\n// is available.\n\nvar util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'oldIE-userDataStorage',\n\twrite: write,\n\tread: read,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar storageName = 'storejs'\nvar doc = Global.document\nvar _withStorageEl = _makeIEStorageElFunction()\nvar disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\\./) // MSIE 9.x, MSIE 10.x\n\nfunction write(unfixedKey, data) {\n\tif (disable) { return }\n\tvar fixedKey = fixKey(unfixedKey)\n\t_withStorageEl(function(storageEl) {\n\t\tstorageEl.setAttribute(fixedKey, data)\n\t\tstorageEl.save(storageName)\n\t})\n}\n\nfunction read(unfixedKey) {\n\tif (disable) { return }\n\tvar fixedKey = fixKey(unfixedKey)\n\tvar res = null\n\t_withStorageEl(function(storageEl) {\n\t\tres = storageEl.getAttribute(fixedKey)\n\t})\n\treturn res\n}\n\nfunction each(callback) {\n\t_withStorageEl(function(storageEl) {\n\t\tvar attributes = storageEl.XMLDocument.documentElement.attributes\n\t\tfor (var i=attributes.length-1; i>=0; i--) {\n\t\t\tvar attr = attributes[i]\n\t\t\tcallback(storageEl.getAttribute(attr.name), attr.name)\n\t\t}\n\t})\n}\n\nfunction remove(unfixedKey) {\n\tvar fixedKey = fixKey(unfixedKey)\n\t_withStorageEl(function(storageEl) {\n\t\tstorageEl.removeAttribute(fixedKey)\n\t\tstorageEl.save(storageName)\n\t})\n}\n\nfunction clearAll() {\n\t_withStorageEl(function(storageEl) {\n\t\tvar attributes = storageEl.XMLDocument.documentElement.attributes\n\t\tstorageEl.load(storageName)\n\t\tfor (var i=attributes.length-1; i>=0; i--) {\n\t\t\tstorageEl.removeAttribute(attributes[i].name)\n\t\t}\n\t\tstorageEl.save(storageName)\n\t})\n}\n\n// Helpers\n//////////\n\n// In IE7, keys cannot start with a digit or contain certain chars.\n// See https://github.com/marcuswestin/store.js/issues/40\n// See https://github.com/marcuswestin/store.js/issues/83\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\")\nfunction fixKey(key) {\n\treturn key.replace(/^\\d/, '___$&').replace(forbiddenCharsRegex, '___')\n}\n\nfunction _makeIEStorageElFunction() {\n\tif (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {\n\t\treturn null\n\t}\n\tvar scriptTag = 'script',\n\t\tstorageOwner,\n\t\tstorageContainer,\n\t\tstorageEl\n\n\t// Since #userData storage applies only to specific paths, we need to\n\t// somehow link our data to a specific path.  We choose /favicon.ico\n\t// as a pretty safe option, since all browsers already make a request to\n\t// this URL anyway and being a 404 will not hurt us here.  We wrap an\n\t// iframe pointing to the favicon in an ActiveXObject(htmlfile) object\n\t// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)\n\t// since the iframe access rules appear to allow direct access and\n\t// manipulation of the document element, even for a 404 page.  This\n\t// document can be used instead of the current document (which would\n\t// have been limited to the current path) to perform #userData storage.\n\ttry {\n\t\t/* global ActiveXObject */\n\t\tstorageContainer = new ActiveXObject('htmlfile')\n\t\tstorageContainer.open()\n\t\tstorageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src=\"/favicon.ico\"></iframe>')\n\t\tstorageContainer.close()\n\t\tstorageOwner = storageContainer.w.frames[0].document\n\t\tstorageEl = storageOwner.createElement('div')\n\t} catch(e) {\n\t\t// somehow ActiveXObject instantiation failed (perhaps some special\n\t\t// security settings or otherwse), fall back to per-path storage\n\t\tstorageEl = doc.createElement('div')\n\t\tstorageOwner = doc.body\n\t}\n\n\treturn function(storeFunction) {\n\t\tvar args = [].slice.call(arguments, 0)\n\t\targs.unshift(storageEl)\n\t\t// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx\n\t\t// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx\n\t\tstorageOwner.appendChild(storageEl)\n\t\tstorageEl.addBehavior('#default#userData')\n\t\tstorageEl.load(storageName)\n\t\tstoreFunction.apply(this, args)\n\t\tstorageOwner.removeChild(storageEl)\n\t\treturn\n\t}\n}\n","var util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'sessionStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll\n}\n\nfunction sessionStorage() {\n\treturn Global.sessionStorage\n}\n\nfunction read(key) {\n\treturn sessionStorage().getItem(key)\n}\n\nfunction write(key, data) {\n\treturn sessionStorage().setItem(key, data)\n}\n\nfunction each(fn) {\n\tfor (var i = sessionStorage().length - 1; i >= 0; i--) {\n\t\tvar key = sessionStorage().key(i)\n\t\tfn(read(key), key)\n\t}\n}\n\nfunction remove(key) {\n\treturn sessionStorage().removeItem(key)\n}\n\nfunction clearAll() {\n\treturn sessionStorage().clear()\n}\n","module.exports = React;","module.exports = ReactDOM;","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","'use strict';\n\nexport default function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n","'use strict';\n\nimport bind from './helpers/bind.js';\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  const pattern = '[object FormData]';\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) ||\n    toString.call(thing) === pattern ||\n    (isFunction(thing.toString) && thing.toString() === pattern)\n  );\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[_-\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    if (reducer(descriptor, name, obj) !== false) {\n      reducedDescriptors[name] = descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  toJSONObject\n};\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nconst prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nexport default AxiosError;\n","import FormData from 'form-data';\nexport default FormData;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\nimport envFormData from '../env/classes/FormData.js';\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliant(thing) {\n  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];\n}\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (envFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && isSpecCompliant(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nexport default toFormData;\n","'use strict';\n\nimport toFormData from './toFormData.js';\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nexport default AxiosURLSearchParams;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosURLSearchParams from '../helpers/AxiosURLSearchParams.js';\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nexport default function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nexport default InterceptorManager;\n","'use strict';\n\nexport default {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n","'use strict';\n\nimport AxiosURLSearchParams from '../../../helpers/AxiosURLSearchParams.js';\nexport default typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n","'use strict';\n\nexport default FormData;\n","import URLSearchParams from './classes/URLSearchParams.js'\nimport FormData from './classes/FormData.js'\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst isStandardBrowserEnv = (() => {\n  let product;\n  if (typeof navigator !== 'undefined' && (\n    (product = navigator.product) === 'ReactNative' ||\n    product === 'NativeScript' ||\n    product === 'NS')\n  ) {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n})();\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\n const isStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\n\nexport default {\n  isBrowser: true,\n  classes: {\n    URLSearchParams,\n    FormData,\n    Blob\n  },\n  isStandardBrowserEnv,\n  isStandardBrowserWebWorkerEnv,\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nexport default formDataToJSON;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\nimport transitionalDefaults from './transitional.js';\nimport toFormData from '../helpers/toFormData.js';\nimport toURLEncodedForm from '../helpers/toURLEncodedForm.js';\nimport platform from '../platform/index.js';\nimport formDataToJSON from '../helpers/formDataToJSON.js';\n\nconst DEFAULT_CONTENT_TYPE = {\n  'Content-Type': undefined\n};\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      if (!hasJSONContentType) {\n        return data;\n      }\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nexport default defaults;\n","'use strict';\n\nimport utils from '../utils.js';\nimport toFormData from './toFormData.js';\nimport platform from '../platform/index.js';\n\nexport default function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nexport default rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nfunction isValidHeaderName(str) {\n  return /^[-_a-zA-Z]+$/.test(str.trim());\n}\n\nfunction matchHeaderValue(context, value, header, filter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear() {\n    return Object.keys(this).forEach(this.delete.bind(this));\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent']);\n\nutils.freezeMethods(AxiosHeaders.prototype);\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n","'use strict';\n\nimport utils from './../utils.js';\nimport defaults from '../defaults/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nexport default function transformData(fns, response) {\n  const config = this || defaults;\n  const context = response || config;\n  const headers = AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n","'use strict';\n\nexport default function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n","'use strict';\n\nimport AxiosError from '../core/AxiosError.js';\nimport utils from '../utils.js';\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nexport default CanceledError;\n","'use strict';\n\nimport utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.isStandardBrowserEnv ?\n\n// Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        const cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n// Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })();\n","'use strict';\n\nimport isAbsoluteURL from '../helpers/isAbsoluteURL.js';\nimport combineURLs from '../helpers/combineURLs.js';\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nexport default function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nexport default function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nexport default function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n","'use strict';\n\nimport utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.isStandardBrowserEnv ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    const msie = /(msie|trident)/i.test(navigator.userAgent);\n    const urlParsingNode = document.createElement('a');\n    let originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      let href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n          urlParsingNode.pathname :\n          '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n          parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })();\n","'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n","'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport cookies from './../helpers/cookies.js';\nimport buildURL from './../helpers/buildURL.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport isURLSameOrigin from './../helpers/isURLSameOrigin.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport speedometer from '../helpers/speedometer.js';\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e\n    };\n\n    data[isDownloadStream ? 'download' : 'upload'] = true;\n\n    listener(data);\n  };\n}\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    let requestData = config.data;\n    const requestHeaders = AxiosHeaders.from(config.headers).normalize();\n    const responseType = config.responseType;\n    let onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {\n      requestHeaders.setContentType(false); // Let the browser set it\n    }\n\n    let request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));\n    }\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (platform.isStandardBrowserEnv) {\n      // Add xsrf header\n      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))\n        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n\n      if (xsrfValue) {\n        requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(fullPath);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n","import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if(fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nexport default {\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {\n        break;\n      }\n    }\n\n    if (!adapter) {\n      if (adapter === false) {\n        throw new AxiosError(\n          `Adapter ${nameOrAdapter} is not supported by the environment`,\n          'ERR_NOT_SUPPORT'\n        );\n      }\n\n      throw new Error(\n        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?\n          `Adapter '${nameOrAdapter}' is not available in the build` :\n          `Unknown adapter '${nameOrAdapter}'`\n      );\n    }\n\n    if (!utils.isFunction(adapter)) {\n      throw new TypeError('adapter is not a function');\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n}\n","// eslint-disable-next-line strict\nexport default null;\n","'use strict';\n\nimport AxiosError from './AxiosError.js';\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nexport default function settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n","'use strict';\n\nexport default function parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n","'use strict';\n\nimport transformData from './transformData.js';\nimport isCancel from '../cancel/isCancel.js';\nimport defaults from '../defaults/index.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport adapters from \"../adapters/adapters.js\";\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nexport default function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosHeaders from \"./AxiosHeaders.js\";\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders ? thing.toJSON() : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nexport default function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n","export const VERSION = \"1.2.3\";","'use strict';\n\nimport {VERSION} from '../env/data.js';\nimport AxiosError from '../core/AxiosError.js';\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nexport default {\n  assertOptions,\n  validators\n};\n","'use strict';\n\nimport utils from './../utils.js';\nimport buildURL from '../helpers/buildURL.js';\nimport InterceptorManager from './InterceptorManager.js';\nimport dispatchRequest from './dispatchRequest.js';\nimport mergeConfig from './mergeConfig.js';\nimport buildFullPath from './buildFullPath.js';\nimport validator from '../helpers/validator.js';\nimport AxiosHeaders from './AxiosHeaders.js';\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer !== undefined) {\n      validator.assertOptions(paramsSerializer, {\n        encode: validators.function,\n        serialize: validators.function\n      }, true);\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    let contextHeaders;\n\n    // Flatten headers\n    contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    contextHeaders && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nexport default Axios;\n","'use strict';\n\nimport CanceledError from './CanceledError.js';\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n","const HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nexport default HttpStatusCode;\n","'use strict';\n\nimport utils from './utils.js';\nimport bind from './helpers/bind.js';\nimport Axios from './core/Axios.js';\nimport mergeConfig from './core/mergeConfig.js';\nimport defaults from './defaults/index.js';\nimport formDataToJSON from './helpers/formDataToJSON.js';\nimport CanceledError from './cancel/CanceledError.js';\nimport CancelToken from './cancel/CancelToken.js';\nimport isCancel from './cancel/isCancel.js';\nimport {VERSION} from './env/data.js';\nimport toFormData from './helpers/toFormData.js';\nimport AxiosError from './core/AxiosError.js';\nimport spread from './helpers/spread.js';\nimport isAxiosError from './helpers/isAxiosError.js';\nimport AxiosHeaders from \"./core/AxiosHeaders.js\";\nimport HttpStatusCode from './helpers/HttpStatusCode.js';\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios(defaultConfig);\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders;\n\naxios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.HttpStatusCode = HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\nexport default axios\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nexport default function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nexport default function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"0\":\"fb27c18d\",\"11\":\"616975ff\",\"27\":\"ba0a32fa\",\"120\":\"ab1d0fa2\",\"221\":\"b8bb0717\",\"296\":\"bcb86d21\",\"474\":\"b9bbb4d8\",\"487\":\"3c10371e\",\"576\":\"eb4ccb88\",\"633\":\"2160e5e1\",\"650\":\"d733e6e3\",\"705\":\"85601393\",\"777\":\"a4912ef2\",\"820\":\"cc7026e7\",\"889\":\"0cb9ca4c\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/css/\" + chunkId + \".\" + {\"11\":\"82ef4d4e\",\"120\":\"af921502\",\"221\":\"31d6cfe0\",\"487\":\"9471f847\",\"777\":\"60bd63d4\",\"889\":\"692f1b22\"}[chunkId] + \".chunk.css\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","var inProgress = {};\nvar dataWebpackPrefix = \"geek-pc:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function(url, done, key, chunkId) {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function(prev, event) {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach(function(fn) { return fn(event); });\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/hanhealthapp/\";","var createStylesheet = function(chunkId, fullhref, oldTag, resolve, reject) {\n\tvar linkTag = document.createElement(\"link\");\n\n\tlinkTag.rel = \"stylesheet\";\n\tlinkTag.type = \"text/css\";\n\tvar onLinkComplete = function(event) {\n\t\t// avoid mem leaks.\n\t\tlinkTag.onerror = linkTag.onload = null;\n\t\tif (event.type === 'load') {\n\t\t\tresolve();\n\t\t} else {\n\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\tvar realHref = event && event.target && event.target.href || fullhref;\n\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + realHref + \")\");\n\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n\t\t\terr.type = errorType;\n\t\t\terr.request = realHref;\n\t\t\tlinkTag.parentNode.removeChild(linkTag)\n\t\t\treject(err);\n\t\t}\n\t}\n\tlinkTag.onerror = linkTag.onload = onLinkComplete;\n\tlinkTag.href = fullhref;\n\n\tif (oldTag) {\n\t\toldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);\n\t} else {\n\t\tdocument.head.appendChild(linkTag);\n\t}\n\treturn linkTag;\n};\nvar findStylesheet = function(href, fullhref) {\n\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n\tfor(var i = 0; i < existingLinkTags.length; i++) {\n\t\tvar tag = existingLinkTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return tag;\n\t}\n\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n\tfor(var i = 0; i < existingStyleTags.length; i++) {\n\t\tvar tag = existingStyleTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\");\n\t\tif(dataHref === href || dataHref === fullhref) return tag;\n\t}\n};\nvar loadStylesheet = function(chunkId) {\n\treturn new Promise(function(resolve, reject) {\n\t\tvar href = __webpack_require__.miniCssF(chunkId);\n\t\tvar fullhref = __webpack_require__.p + href;\n\t\tif(findStylesheet(href, fullhref)) return resolve();\n\t\tcreateStylesheet(chunkId, fullhref, null, resolve, reject);\n\t});\n}\n// object to store loaded CSS chunks\nvar installedCssChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.miniCss = function(chunkId, promises) {\n\tvar cssChunks = {\"11\":1,\"120\":1,\"221\":1,\"487\":1,\"777\":1,\"889\":1};\n\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n\t\tpromises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(function() {\n\t\t\tinstalledCssChunks[chunkId] = 0;\n\t\t}, function(e) {\n\t\t\tdelete installedCssChunks[chunkId];\n\t\t\tthrow e;\n\t\t}));\n\t}\n};\n\n// no hmr","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = function(chunkId, promises) {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = function(event) {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkgeek_pc\"] = self[\"webpackChunkgeek_pc\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// 1. 判斷 token 是否存在\r\n// 2. 如果存在，即可直接正常渲染\r\n// 3. 如果不存在，就重新定巷道登錄路由\r\n\r\n// 高階組件：把一個組件當成另外一個組件的參數傳入\r\n// 然後透過一定的判斷，返回新的組件\r\nimport { getToken } from '@/utils'\r\nimport { Navigate } from 'react-router-dom'\r\n\r\nfunction AuthComponent ({ children }) {\r\n  const isToken = getToken()\r\n  if (isToken) {\r\n    return <>{children}</>\r\n  }\r\n  else {\r\n    return <Navigate to=\"/login\" replace />\r\n  }\r\n}\r\n\r\n// <AuthComponent> <Layout/> </AuthComponent>\r\n// 登錄： <> <Layout/> </>\r\n// 非登錄：<Navigate to=\"/login\" replace/>\r\n\r\nexport { AuthComponent }","// 路由需引入的函式庫組\nimport { unstable_HistoryRouter as HistoryRouter, Routes, Route } from 'react-router-dom'\nimport { history } from './utils/history'\nimport { AuthComponent } from '@/components/AuthComponent'\nimport './App.css'\nimport { lazy, Suspense } from 'react'\n\n// 按需導入組件\nconst Login = lazy(() => import('./pages/Login'))\nconst Layout = lazy(() => import('./pages/Layout'))\nconst Home = lazy(() => import('./pages/Home'))\nconst Article = lazy(() => import('./pages/Article'))\nconst Publish = lazy(() => import('./pages/Publish'))\nconst Register = lazy(() => import('./pages/Register'))\n\n\n\nfunction App () {\n  return (\n    // 路由配置\n    <HistoryRouter history={history}>\n      <div className=\"App\">\n        <Suspense\n          fallback={\n            <div\n              style={{\n                textAlign: 'center',\n                marginTop: 200\n              }}\n            >\n              loading...\n            </div>\n          }\n        >\n          <Routes>\n            {/* 創建路由 path 和組件對應關係 */}\n            {/* Layout 需要鑒權處理 */}\n            {/* 這裡的 Layout 不一定不能寫死，要根據是否登錄來進行判斷 */}\n            <Route path='/' element={\n              <AuthComponent>\n                <Layout />\n              </AuthComponent>\n            }>\n              <Route index element={<Home />}></Route>\n              <Route path='article' element={<Article />}></Route>\n              <Route path='publish' element={<Publish />}></Route>\n            </Route>\n            {/* 這個不需要 */}\n            <Route path='/Login' element={<Login />} />\n            <Route path='/register' element={<Register />} />\n            <Route path='/user/profile/:tel' element={<Layout />} />\n          </Routes>\n        </Suspense>\n      </div>\n    </HistoryRouter>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App'\n\n// 引入 index.scss 文件\nimport './index.scss'\n\nconst root = ReactDOM.createRoot(document.getElementById('root'))\nroot.render(\n  <App />\n)\n"],"names":["history","createBrowserHistory","key","setToken","token","window","localStorage","setItem","getToken","getItem","removeToken","removeItem","http","axios","baseURL","timeout","interceptors","request","use","config","headers","Authorization","error","Promise","reject","response","data","console","dir","status","removeUser","USER_KEY","saveRem","rem","store","getRem","removeRem","saveUser","tel","getUser","_construct","Parent","args","Class","isNativeReflectConstruct","Reflect","construct","bind","a","push","apply","instance","Function","setPrototypeOf","prototype","arguments","_wrapNativeSuper","_cache","Map","undefined","fn","toString","call","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","this","constructor","Object","create","value","enumerable","writable","configurable","Action","ResultType","invariant","message","Error","createPath","_ref","pathname","search","hash","charAt","parsePath","path","parsedPath","hashIndex","substr","searchIndex","matchRoutes","routes","locationArg","basename","stripBasename","branches","flattenRoutes","sort","b","score","siblings","length","slice","every","n","i","compareIndexes","routesMeta","map","meta","childrenIndex","rankRouteBranches","matches","matchRouteBranch","safelyDecodeURI","parentsMeta","parentPath","flattenRoute","route","index","relativePath","caseSensitive","startsWith","joinPaths","concat","children","computeScore","forEach","_route$path","includes","explodeOptionalSegments","exploded","segments","split","first","rest","isOptional","endsWith","required","replace","restExploded","join","result","subpath","paramRe","isSplat","s","initialScore","some","filter","reduce","segment","test","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","assign","params","pathnameBase","normalizePathname","pattern","warning","paramNames","regexpSource","_","paramName","matcher","RegExp","compilePath","captureGroups","memo","splatValue","decodeURIComponent","safelyDecodeURIComponent","decodeURI","toLowerCase","startIndex","nextChar","cond","warn","e","getInvalidPathError","char","field","dest","JSON","stringify","getPathContributingMatches","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","to","from","isEmptyPath","toPathname","routePathnameIndex","toSegments","shift","fromPathname","pop","resolvePathname","normalizeSearch","normalizeHash","resolvePath","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","AbortedDeferredError","ErrorResponse","statusText","internal","isRouteErrorResponse","validMutationMethodsArr","validRequestMethodsArr","Set","document","createElement","module","exports","self","FormData","m","require","createRoot","hydrateRoot","createSearchParams","init","URLSearchParams","Array","isArray","keys","v","HistoryRouter","_ref3","React","action","location","state","setState","listen","Router","navigationType","navigator","Link","ref","onClick","_ref4","relative","reloadDocument","target","preventScrollReset","href","useHref","internalOnClick","_temp","replaceProp","navigate","useNavigate","useLocation","useResolvedPath","event","button","metaKey","altKey","ctrlKey","shiftKey","isModifiedEvent","shouldProcessLinkClick","preventDefault","useLinkClickHandler","defaultPrevented","DataRouterHook","DataRouterStateHook","useSearchParams","defaultInit","defaultSearchParamsRef","searchParams","locationSearch","defaultSearchParams","getAll","append","getSearchParamsForLocation","current","setSearchParams","nextInit","navigateOptions","newSearchParams","is","x","y","useState","useEffect","useLayoutEffect","useDebugValue","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","prevValue","nextValue","shim","subscribe","getServerSnapshot","forceUpdate","DataRouterContext","useSyncExternalStore","DataRouterStateContext","AwaitContext","NavigationContext","LocationContext","RouteContext","outlet","RouteErrorContext","useInRouterContext","joinedPathname","createHref","routePathnamesJson","activeRef","options","parse","go","OutletContext","_temp2","DefaultErrorElement","useDataRouterState","UseRouteError","routeId","useCurrentRouteId","errors","useRouteError","stack","lightgrey","preStyles","padding","backgroundColor","codeStyles","style","fontStyle","RenderErrorBoundary","props","componentDidCatch","errorInfo","render","Provider","routeContext","component","RenderedRoute","dataRouterContext","static","staticContext","errorElement","_deepestRenderedBoundaryId","id","_renderMatches","parentMatches","dataRouterState","renderedMatches","errorIndex","findIndex","Math","min","reduceRight","getChildren","element","hookName","useRouteContext","thisRoute","AwaitRenderStatus","Navigate","navigation","Outlet","context","useOutlet","Route","_props","basenameProp","locationProp","NavigationType","staticProp","navigationContext","trailingPathname","Routes","_ref5","dataRouterStateContext","routeMatch","parentParams","parentPathnameBase","locationFromContext","parsedLocationArg","encodeLocation","useRoutes","router","createRoutesFromChildren","neverSettledPromise","type","treePath","loader","hasErrorBoundary","shouldRevalidate","handle","f","k","Symbol","for","l","hasOwnProperty","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","p","__self","__source","q","c","g","d","h","defaultProps","$$typeof","_owner","Fragment","jsx","jsxs","engine","storages","plugins","createStore","rx_one","rx_two","rx_three","rx_four","rx_escapable","rx_dangerous","gap","indent","rep","this_value","valueOf","quote","string","lastIndex","charCodeAt","str","holder","partial","mind","toJSON","isFinite","String","Date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","Boolean","Number","replacer","space","text","reviver","j","walk","eval","SyntaxError","util","pluck","each","isList","isFunction","isObject","storeAPI","version","enabled","optionalDefaultValue","storage","read","_namespacePrefix","_deserialize","remove","write","_serialize","callback","val","namespacedKey","_namespaceRegexp","clearAll","hasNamespace","namespace","addPlugin","plugin","_addPlugin","namespacePrefix","namespaceRegexp","_privateStoreProps","_testStorage","testStr","ok","_assignPluginFnProp","pluginFnProp","propName","oldFn","super_fn","arg","newFnArgs","obj","strVal","defaultVal","_addStorage","seenPlugin","pluginProperties","name","addStorage","_console","log","_warn","raw","prop","props1","props2","etc","assignProps1","assignProps2","assignArgsList","F","make_create","trim","Global","global","arr","res","_has","regexpStr","escape","unescape","doc","cookie","cookies","kvp","clear","memoryStorage","globalStorage","unfixedKey","disable","fixedKey","fixKey","_withStorageEl","storageEl","setAttribute","save","storageName","getAttribute","attributes","XMLDocument","documentElement","attr","removeAttribute","load","addBehavior","storageOwner","storageContainer","scriptTag","ActiveXObject","open","close","w","frames","body","storeFunction","unshift","appendChild","removeChild","_makeIEStorageElFunction","userAgent","forbiddenCharsRegex","sessionStorage","ReactDOM","_arrayLikeToArray","len","arr2","_arrayWithHoles","_assertThisInitialized","ReferenceError","_classCallCheck","Constructor","_defineProperties","descriptor","defineProperty","_createClass","protoProps","staticProps","_createForOfIteratorHelper","o","allowArrayLike","it","iterator","done","_e","err","normalCompletion","didErr","step","next","_e2","_possibleConstructorReturn","assertThisInitialized","_createSuper","Derived","hasNativeReflectConstruct","Super","NewTarget","_extends","source","_getPrototypeOf","__proto__","_inherits","subClass","superClass","_isNativeReflectConstruct","sham","Proxy","_iterableToArray","iter","_nonIterableRest","_setPrototypeOf","_slicedToArray","arrayWithHoles","_i","_s","_x","_r","_arr","_n","_d","unsupportedIterableToArray","nonIterableRest","_toArray","_toConsumableArray","arrayLikeToArray","iterableToArray","_toPropertyKey","input","hint","prim","toPrimitive","_typeof","_unsupportedIterableToArray","minLen","thisArg","cache","kindOf","thing","kindOfTest","typeOfTest","isUndefined","isArrayBuffer","isString","isNumber","isPlainObject","toStringTag","isDate","isFile","isBlob","isFileList","isURLSearchParams","allOwnKeys","getOwnPropertyNames","findKey","_key","_global","globalThis","isContextDefined","TypedArray","isTypedArray","Uint8Array","isHTMLForm","isRegExp","reduceDescriptors","reducer","descriptors","getOwnPropertyDescriptors","reducedDescriptors","defineProperties","isBuffer","isFormData","isArrayBufferView","ArrayBuffer","isView","buffer","isBoolean","isStream","pipe","merge","caseless","assignValue","targetKey","extend","stripBOM","content","inherits","superConstructor","toFlatObject","sourceObj","destObj","propFilter","merged","searchString","position","toArray","forEachEntry","pair","matchAll","regExp","exec","hasOwnProp","freezeMethods","toObjectSet","arrayOrString","delimiter","define","toCamelCase","p1","p2","toUpperCase","noop","toFiniteNumber","defaultValue","toJSONObject","visit","reducedValue","AxiosError","code","captureStackTrace","utils","description","number","fileName","lineNumber","columnNumber","customProps","axiosError","cause","isVisitable","removeBrackets","renderKey","dots","predicates","formData","envFormData","metaTokens","indexes","option","visitor","defaultVisitor","useBlob","Blob","convertValue","toISOString","Buffer","isFlatArray","el","exposedHelpers","build","encode","charMap","encodeURIComponent","AxiosURLSearchParams","_pairs","toFormData","encoder","_encode","buildURL","url","serializedParams","serializeFn","serialize","hashmarkIndex","handlers","fulfilled","rejected","synchronous","runWhen","silentJSONParsing","forcedJSONParsing","clarifyTimeoutError","isStandardBrowserEnv","product","isStandardBrowserWebWorkerEnv","WorkerGlobalScope","importScripts","isBrowser","classes","protocols","buildPath","isNumericKey","isLast","arrayToObject","entries","parsePropPath","DEFAULT_CONTENT_TYPE","defaults","transitional","transitionalDefaults","adapter","transformRequest","contentType","getContentType","hasJSONContentType","isObjectPayload","formDataToJSON","setContentType","platform","helpers","toURLEncodedForm","formSerializer","_FormData","env","rawValue","parser","stringifySafely","transformResponse","JSONRequested","responseType","strictJSONParsing","xsrfCookieName","xsrfHeaderName","maxContentLength","maxBodyLength","validateStatus","common","method","ignoreDuplicateOf","$internals","normalizeHeader","header","normalizeValue","matchHeaderValue","AxiosHeaders","valueOrRewrite","rewrite","setHeader","_value","_header","_rewrite","lHeader","setHeaders","rawHeaders","parsed","line","substring","parseHeaders","tokens","tokensRE","parseTokens","deleted","deleteHeader","delete","format","normalized","formatHeader","targets","asStrings","computed","accessors","defineAccessor","accessorName","methodName","arg1","arg2","arg3","buildAccessors","accessor","transformData","fns","normalize","isCancel","__CANCEL__","CanceledError","expires","domain","secure","toGMTString","now","buildFullPath","requestedURL","relativeURL","combineURLs","originURL","msie","urlParsingNode","resolveURL","protocol","host","hostname","port","requestURL","samplesCount","firstSampleTS","bytes","timestamps","head","tail","chunkLength","startedAt","bytesCount","passed","round","progressEventReducer","listener","isDownloadStream","bytesNotified","_speedometer","speedometer","loaded","total","lengthComputable","progressBytes","rate","progress","estimated","knownAdapters","xhr","XMLHttpRequest","resolve","onCanceled","requestData","requestHeaders","cancelToken","unsubscribe","signal","removeEventListener","auth","username","password","btoa","fullPath","onloadend","responseHeaders","getAllResponseHeaders","floor","settle","responseText","paramsSerializer","onreadystatechange","readyState","responseURL","setTimeout","onabort","onerror","ontimeout","timeoutErrorMessage","xsrfValue","withCredentials","isURLSameOrigin","setRequestHeader","onDownloadProgress","addEventListener","onUploadProgress","upload","cancel","abort","aborted","parseProtocol","send","adapters","nameOrAdapter","throwIfCancellationRequested","throwIfRequested","dispatchRequest","then","reason","headersToObject","mergeConfig","config1","config2","getMergedValue","mergeDeepProperties","valueFromConfig2","defaultToConfig2","mergeDirectKeys","mergeMap","timeoutMessage","decompress","beforeRedirect","transport","httpAgent","httpsAgent","socketPath","responseEncoding","configValue","VERSION","validators","deprecatedWarnings","validator","formatMessage","opt","desc","opts","assertOptions","schema","allowUnknown","Axios","instanceConfig","InterceptorManager","configOrUrl","contextHeaders","boolean","function","requestInterceptorChain","synchronousRequestInterceptors","interceptor","promise","responseInterceptorChain","chain","newConfig","onFulfilled","onRejected","generateHTTPMethod","isForm","executor","resolvePromise","_listeners","onfulfilled","_resolve","splice","CancelToken","HttpStatusCode","Continue","SwitchingProtocols","Processing","EarlyHints","Ok","Created","Accepted","NonAuthoritativeInformation","NoContent","ResetContent","PartialContent","MultiStatus","AlreadyReported","ImUsed","MultipleChoices","MovedPermanently","Found","SeeOther","NotModified","UseProxy","Unused","TemporaryRedirect","PermanentRedirect","BadRequest","Unauthorized","PaymentRequired","Forbidden","NotFound","MethodNotAllowed","NotAcceptable","ProxyAuthenticationRequired","RequestTimeout","Conflict","Gone","LengthRequired","PreconditionFailed","PayloadTooLarge","UriTooLong","UnsupportedMediaType","RangeNotSatisfiable","ExpectationFailed","ImATeapot","MisdirectedRequest","UnprocessableEntity","Locked","FailedDependency","TooEarly","UpgradeRequired","PreconditionRequired","TooManyRequests","RequestHeaderFieldsTooLarge","UnavailableForLegalReasons","InternalServerError","NotImplemented","BadGateway","ServiceUnavailable","GatewayTimeout","HttpVersionNotSupported","VariantAlsoNegotiates","InsufficientStorage","LoopDetected","NotExtended","NetworkAuthenticationRequired","createInstance","defaultConfig","Cancel","all","promises","spread","isAxiosError","payload","formToJSON","default","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","chunkId","u","miniCssF","inProgress","dataWebpackPrefix","script","needAttach","scripts","getElementsByTagName","charset","nc","src","onScriptComplete","prev","onload","clearTimeout","doneFns","parentNode","r","nmd","loadStylesheet","fullhref","existingLinkTags","dataHref","tag","rel","existingStyleTags","findStylesheet","oldTag","linkTag","errorType","realHref","insertBefore","nextSibling","createStylesheet","installedCssChunks","miniCss","installedChunks","installedChunkData","realSrc","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","chunkLoadingGlobal","AuthComponent","Login","lazy","Layout","Home","Article","Publish","Register","className","Suspense","fallback","textAlign","marginTop","getElementById"],"sourceRoot":""}